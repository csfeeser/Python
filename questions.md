# Question Bank

## A complete set of known commands is called:

**Domain:** Basics

### Options:
- âŒ **a low-level list**
  - A 'low-level list' does not accurately describe a complete set of known commands in Python.

- âŒ **a machine list**
  - There is no concept of a 'machine list' in Python.

- âœ… **an instruction list**
  - In Python, a complete set of known commands is referred to as an instruction list.

### Explanation:
A complete set of known commands is called an instruction list, sometimes abbreviated to IL.

---

## What value will be assigned to the x variable?

**Domain:** Operators

### Options:
- âŒ **1**
  - The expression evaluates to a boolean value, not a numerical value.

- âŒ **0**
  - The expression evaluates to a boolean value, not a numerical value.

- âŒ **True**
  - The expression evaluates to False, not True.

- âœ… **False**
  - The logical expression evaluates to False because of operator precedence.

### Explanation:
Boolean expressions follow precedence rules, and this one evaluates to False.

---

## What is the output of the following code?

a = 10
b = 20
c = a > b
print(not(c))

**Domain:** Operators

### Options:
- âŒ **None**
  - The output will not be None because the logical operation evaluates to a boolean value.

- âŒ **The program will cause an error**
  - There are no syntax errors in the program.

- âœ… **True**
  - The expression 'a > b' evaluates to False, and 'not False' is True.

- âŒ **False**
  - The expression 'a > b' evaluates to False, but 'not False' results in True.

### Explanation:
The 'not' operator inverts the boolean value, leading to True.

---

## What would you insert instead of ??? in the loop so that the program prints the following pattern?

11111
22222
33333
44444
55555

**Domain:** Control Flow

### Options:
- âŒ **n**
  - Using just `n` would not produce repeated characters.

- âŒ **-1**
  - A constant value will not produce the required pattern.

- âœ… **str(n)**
  - Using `str(n)` allows the number to be repeated correctly.

### Explanation:
By converting n to a string and using multiplication, the desired output is achieved.

---

## What is the expected output of the following code?

def func(message, num=1):
    print(message * num)

func('Hello')
func('Welcome', 3)

**Domain:** Functions

### Options:
- âŒ **Hello
Viewers**
  - This is incorrect because the second function call prints 'Welcome' three times.

- âœ… **Hello
WelcomeWelcomeWelcome**
  - The function prints 'Hello' once, then 'Welcome' three times due to string multiplication.

- âŒ **Hello**
  - This does not account for the second function call.

### Explanation:
The function uses string multiplication, repeating the message based on the given parameter.

---

## What is the best definition of a script?

**Domain:** Basics

### Options:
- âŒ **It's an error message generated by the interpreter**
  - An error message is not a script; a script is a text file containing instructions.

- âŒ **It's a text file that contains sequences of zeroes and ones**
  - A script is written in human-readable code, not raw binary data.

- âœ… **It's a text file that contains instructions which make up a Python program**
  - A script is a file with commands that can be executed by an interpreter.

- âŒ **It's an error message generated by the compiler**
  - A script is not an error message; it is a set of instructions.

### Explanation:
A script is a text file containing code written in a programming language.

---

## What is the output of the following snippet?

my_list = [x * x for x in range(5)]

def fun(lst):
    del lst[lst[2]]
    return lst

print(fun(my_list))

**Domain:** Data Aggregates

### Options:
- âŒ **[1, 4, 9, 16]**
  - The function modifies my_list by deleting an element based on its value.

- âœ… **[0, 1, 4, 9]**
  - The function deletes the element at index 4 (value 16), resulting in this list.

- âŒ **[0, 1, 4, 16]**
  - Incorrect, as the element at index 4 (16) is removed.

- âŒ **[0, 1, 9, 16]**
  - Incorrect, as index 4 (16) is removed, not index 2.

### Explanation:
The function deletes an element based on its index, modifying the list accordingly.

---

## What is the expected output of the following code?

num = 1

def func():
    num = 3
    print(num, end=' ')

func()
print(num)

**Domain:** Functions

### Options:
- âŒ **The code is erroneous.**
  - The code is valid; the function defines a local variable with the same name as a global variable.

- âœ… **3 1**
  - Inside the function, num is 3, but the global num remains 1.

- âŒ **1 3**
  - The local num in the function does not modify the global num.

- âŒ **1 1**
  - The function prints 3, not 1.

### Explanation:
Variable scope determines whether a variable refers to a global or local value.

---

## What is the expected output of the following code if the user enters 11 and 4?

x = int(input())
y = int(input())
x = x % y
x = x % y
y = y % x
print(y)

**Domain:** Data Types

### Options:
- âœ… **1**
  - Modulo operations result in y being assigned 1.

- âŒ **2**
  - Incorrect modulo calculations lead to a different result.

- âŒ **3**
  - Incorrect, as the modulus sequence does not result in 3.

- âŒ **4**
  - Incorrect, as y is modified before printing.

### Explanation:
The modulus operator repeatedly reduces values, leading to a final result of 1.

---

## What is the expected output of the following code?

print(1 // 2 * 3)

**Domain:** Operators

### Options:
- âŒ **4.5**
  - Floor division rounds down, so 1 // 2 results in 0.

- âœ… **0**
  - 1 // 2 is 0, and 0 * 3 is still 0.

- âŒ **0.0**
  - The result is an integer, not a float.

- âŒ **0.16666666666666666**
  - This would be true for floating-point division (/), but floor division (//) truncates.

### Explanation:
Floor division (//) results in an integer quotient, affecting the final multiplication result.

---

## Which of the following statements is false?

**Domain:** Data Types

### Options:
- âŒ **The None value can be compared with variables.**
  - None can be compared with variables, often to check if a value has been assigned.

- âœ… **The None value may not be used outside functions.**
  - None can be used anywhere in Python, not just inside functions.

- âŒ **The None value can be assigned to variables.**
  - None can be assigned to variables to indicate a lack of value.

- âŒ **The None value cannot be used as an argument of arithmetic operators.**
  - Using None in arithmetic operations results in a TypeError.

### Explanation:
None is a built-in constant representing the absence of a value and can be used globally.

---

## What is the expected output of the following code?

people = {}

def add_person(index):
    if index in people:
        people[index] += 1
    else:
        people[index] = 1

add_person('Peter')
add_person('Paul')
add_person('peter')

print(len(people))

**Domain:** Functions

### Options:
- âŒ **The code is erroneous.**
  - The code correctly modifies a dictionary and does not contain errors.

- âŒ **2**
  - Keys are case-sensitive, so there are three unique entries.

- âœ… **3**
  - The dictionary stores three unique keys: 'Peter', 'Paul', and 'peter'.

- âŒ **1**
  - Each call to add_person adds a unique key to the dictionary.

### Explanation:
Dictionary keys are case-sensitive, so 'Peter' and 'peter' are distinct.

---

## How many stars will the following code print?

x = 0
while x < 6:
    x += 1
    if x % 2 == 0:
        continue
    print('*')

**Domain:** Control Flow

### Options:
- âŒ **zero**
  - The loop does execute, printing '*' three times.

- âŒ **two**
  - The loop skips even numbers but still prints three times.

- âŒ **one**
  - The loop prints three times, not just once.

- âœ… **three**
  - Stars are printed when x is 1, 3, and 5.

### Explanation:
The continue statement skips even numbers, leading to three printed stars.

---

## Which of the following function calls can be used to invoke the below function definition?

def test(a, b, c, d):

**Domain:** Functions

### Options:
- âŒ **test(a=1, 2, c=3, 4)**
  - Mixing keyword and positional arguments incorrectly.

- âœ… **test(a=1, b=2, c=3, d=4)**
  - All parameters are specified using keyword arguments correctly.

- âœ… **test(1, 2, 3, d=4)**
  - Positional arguments followed by a keyword argument are allowed.

- âŒ **test(a=1, b=2, c=3, 4)**
  - Positional arguments cannot follow keyword arguments.

### Explanation:
Keyword arguments must follow positional arguments when calling functions.

---

## UTF-8 is ...

**Domain:** Basics

### Options:
- âŒ **a Python version name.**
  - UTF-8 is an encoding standard, not a Python version.

- âœ… **an encoding form of the Unicode Standard.**
  - UTF-8 is a widely used Unicode encoding.

- âŒ **a synonym for 'byte'.**
  - UTF-8 is a character encoding, not a synonym for byte.

- âŒ **the 9th version of the UTF Standard.**
  - UTF-8 is not a version but an encoding scheme.

### Explanation:
UTF-8 is a widely used encoding format for Unicode characters.

---

## What is the expected output of the following code?

data = [4, 2, 3, 2, 1]
res = data[0]

for d in data:
    if d < res:
        res = d

print(res)

**Domain:** Control Flow

### Options:
- âŒ **res is the sum of all numbers in the list.**
  - No summation occurs in this code.

- âŒ **res is the average of all numbers in the list.**
  - No division is performed to calculate an average.

- âœ… **res is the smallest number in the list.**
  - The loop iterates and updates res to store the smallest number.

- âŒ **res is the largest number in the list.**
  - The logic updates res to hold the smallest value, not the largest.

### Explanation:
This code finds and prints the smallest number in the list.

---

## How many stars will the following code print?

i = 0
while i < i + 2:
    i += 1
    print('*')
else:
    print('*')

**Domain:** Control Flow

### Options:
- âŒ **zero**
  - The loop does execute, but it results in an infinite loop.

- âŒ **one**
  - The loop will not exit, leading to an infinite loop.

- âŒ **two**
  - The loop does not execute normally; it runs indefinitely.

- âœ… **The snippet will enter an infinite loop.**
  - Since i is always smaller than i + 2, the condition never fails.

### Explanation:
The while condition always evaluates to true, creating an infinite loop.

---

## What is the expected output of the following code?

x = True
y = False
x = x or y
y = x and y
x = x or y
print(x, y)

**Domain:** Operators

### Options:
- âŒ **True True**
  - y remains False due to the and operation.

- âœ… **True False**
  - x remains True, while y is assigned False.

- âŒ **False True**
  - x never becomes False.

- âŒ **False False**
  - x is assigned True initially and remains so.

### Explanation:
Boolean logic applies, with x remaining True and y becoming False.

---

## What code would you insert to obtain the expected output?

dictionary = {}
my_list = ['a', 'b', 'c', 'd']

for i in range(len(my_list) - 1):
    dictionary[my_list[i]] = (my_list[i], )

for i in sorted(dictionary.keys()):
    k = dictionary[i]
    # Insert your code here.

**Domain:** Data Aggregates

### Options:
- âœ… **print(k[0])**
  - Each value in the dictionary is a tuple, so we access the first element.

- âŒ **print(k['0'])**
  - Tuples use integer indexing, not string keys.

- âŒ **print(k['0'])**
  - Tuples require numerical indices.

- âŒ **print(k)**
  - This would print the entire tuple instead of just the expected character.

### Explanation:
The dictionary stores tuples, so accessing k[0] correctly extracts the expected value.

---

## What is the expected output of the following code?

data = {}

def func(d, key, value):
    d[key] = value

print(func(data, '1', 'Peter'))

**Domain:** Functions

### Options:
- âŒ **Peter**
  - The function modifies the dictionary but does not return a value.

- âœ… **None**
  - Since func() has no return statement, it implicitly returns None.

- âŒ **The code is erroneous.**
  - The function correctly modifies the dictionary.

- âŒ **value**
  - The function does not return any value.

### Explanation:
Functions without an explicit return statement return None.

---

## What is the output of the following snippet?

def fun(in=2, out=3):
    return in * out

print(fun(3))

**Domain:** Functions

### Options:
- âŒ **9**
  - The function does not execute due to a syntax error.

- âŒ **6**
  - The function cannot execute due to invalid syntax.

- âœ… **The snippet is erroneous (invalid syntax)**
  - Using 'in' as a parameter name is invalid in Python.

### Explanation:
'in' is a reserved keyword in Python and cannot be used as a parameter name.

---

## What is the expected output of the following code?

x = 1 + 1 // 2 + 1 / 2 + 2
print(x)

**Domain:** Operators

### Options:
- âŒ **4**
  - Integer and float division result in 3.5, not 4.

- âŒ **3**
  - Float division results in 3.5, not 3.

- âœ… **3.5**
  - 1 + 0 + 0.5 + 2 evaluates to 3.5.

- âŒ **4.0**
  - The total evaluates to 3.5, not 4.0.

### Explanation:
Python follows operator precedence where integer and float division impact the result.

---

## What is the expected output of the following code?

x = '\\'
print(len(x))

**Domain:** Basics

### Options:
- âŒ **4**
  - The string consists of two backslashes, not four.

- âŒ **1**
  - A single backslash escape is required to represent a backslash.

- âœ… **2**
  - The string '\\' contains two backslashes.

- âŒ **The code is erroneous.**
  - The code correctly evaluates the length of a string.

### Explanation:
Double backslashes in a string represent two actual backslashes, leading to a length of 2.

---

## Which of the following variable names are illegal and will cause a SyntaxError exception?

**Domain:** Basics

### Options:
- âŒ **print**
  - While not recommended, print can be redefined as a variable.

- âœ… **in**
  - 'in' is a reserved keyword in Python and cannot be used as a variable name.

- âŒ **In**
  - Python is case-sensitive, so 'In' is valid.

- âœ… **for**
  - 'for' is a reserved keyword and cannot be used as a variable.

### Explanation:
Reserved keywords like 'in' and 'for' cannot be used as variable names.

---

## What is the expected output of the following code?

data = {'1': '0', '0': '1'}

for d in data.vals():
    print(d, end=' ')

**Domain:** Data Aggregates

### Options:
- âŒ **0 1**
  - The code contains a typo; 'vals()' does not exist.

- âŒ **1 0**
  - The typo in the code causes an error before execution.

- âœ… **The code is erroneous.**
  - The correct method is 'values()', not 'vals()'.

- âŒ **0 0**
  - The function call leads to an error, preventing output.

### Explanation:
The correct method for dictionary values is 'values()', not 'vals()'.

---

## What is the expected output of the following code?

data = [[0, 1, 2, 3] for i in range(2)]
print(data[2][0])

**Domain:** Data Aggregates

### Options:
- âœ… **The code is erroneous.**
  - Index 2 does not exist since the list has only two elements.

- âŒ **0**
  - Index 2 is out of range.

- âŒ **1**
  - Index 2 is out of range.

- âŒ **2**
  - Index 2 is out of range.

### Explanation:
The list comprehension generates only two lists, so accessing index 2 results in an IndexError.

---

## What is the expected output of the following code?

x = 10
y = 20
z = x if x > y else y
print(z)

**Domain:** Control Flow

### Options:
- âŒ **10**
  - The ternary operator evaluates to the larger value, which is 20.

- âœ… **20**
  - Since x is not greater than y, z is assigned the value of y (20).

- âŒ **None**
  - The ternary operator ensures a value is always assigned.

- âŒ **Error**
  - The code is syntactically correct.

### Explanation:
A ternary operator selects one of two values based on a condition.

---

## Which of the following statements about Python lists is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Lists are immutable.**
  - Lists are mutable, meaning they can be modified.

- âœ… **Lists can contain elements of different data types.**
  - Lists can store integers, strings, and other types together.

- âŒ **Lists must always be sorted.**
  - Lists do not have to be sorted; sorting is optional.

- âŒ **Lists are the same as tuples.**
  - Tuples are immutable, while lists are mutable.

### Explanation:
Lists can hold different data types and are mutable, unlike tuples.

---

## What does the expression `bool([])` evaluate to?

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - An empty list evaluates to False in a boolean context.

- âœ… **False**
  - Empty lists, like other empty collections, evaluate to False.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and evaluates to False.

### Explanation:
Empty collections evaluate to False in Python.

---

## What is the expected output of the following code?

def func(x=[]):
    x.append(1)
    print(x)

func()
func()
func()

**Domain:** Functions

### Options:
- âŒ **[1]
[1]
[1]**
  - Default mutable arguments persist between function calls.

- âœ… **[1]
[1, 1]
[1, 1, 1]**
  - Each function call appends to the same list.

- âŒ **[]
[]
[]**
  - The list is modified, so it doesn't remain empty.

- âŒ **None**
  - The function prints a list and does not return None.

### Explanation:
Using a mutable default argument results in persistent modifications across function calls.

---

## What will be the output of the following code?

x = {'a': 1, 'b': 2}
print(x.get('c', 3))

**Domain:** Data Aggregates

### Options:
- âŒ **KeyError**
  - Using .get() prevents a KeyError and returns a default value instead.

- âŒ **None**
  - The default value specified is 3, not None.

- âœ… **3**
  - Since 'c' is not in the dictionary, the default value 3 is returned.

- âŒ **Error**
  - The code executes successfully.

### Explanation:
The .get() method returns a specified default value when a key is not found.

---

## Which of the following statements about Python tuples is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Tuples are mutable.**
  - Tuples are immutable and cannot be modified after creation.

- âœ… **Tuples can contain elements of different data types.**
  - Tuples, like lists, can store different data types.

- âŒ **Tuples must contain at least one element.**
  - Tuples can be empty.

- âŒ **Tuples and lists are the same.**
  - Lists are mutable, while tuples are immutable.

### Explanation:
Tuples can store different data types but are immutable, unlike lists.

---

## What does the expression `set([1, 2, 2, 3, 3, 3])` return?

**Domain:** Data Aggregates

### Options:
- âŒ **{1, 2, 2, 3, 3, 3}**
  - Sets do not allow duplicate values.

- âœ… **{1, 2, 3}**
  - Sets store only unique elements.

- âŒ **[1, 2, 3]**
  - Sets use curly braces, not square brackets.

- âŒ **Error**
  - The expression is valid and returns a set.

### Explanation:
Sets automatically remove duplicate values.

---

## What is the expected output of the following code?

x = [1, 2, 3]
print(x[::-1])

**Domain:** Data Aggregates

### Options:
- âœ… **[3, 2, 1]**
  - The slicing syntax `[::-1]` reverses the list.

- âŒ **[1, 2, 3]**
  - The slicing modifies the order.

- âŒ **Error**
  - The syntax is valid.

- âŒ **None**
  - The function returns a new reversed list, not None.

### Explanation:
Slicing with `[::-1]` reverses the order of list elements.

---

## What will be the output of the following code?

x = {'a': 1, 'b': 2}
print('c' in x)

**Domain:** Data Aggregates

### Options:
- âŒ **True**
  - 'c' is not a key in the dictionary.

- âœ… **False**
  - Since 'c' is not a key, the expression evaluates to False.

- âŒ **None**
  - The expression evaluates to a boolean value.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
Using the `in` operator checks for the presence of a key in a dictionary.

---

## Which of the following statements about Python dictionaries is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Dictionary keys must be integers.**
  - Keys can be any immutable data type.

- âœ… **Dictionaries preserve the insertion order of elements.**
  - Since Python 3.7, dictionaries maintain insertion order.

- âŒ **Dictionaries allow duplicate keys.**
  - Each key in a dictionary must be unique.

- âŒ **Dictionaries are immutable.**
  - Dictionaries are mutable and can be modified.

### Explanation:
Dictionaries maintain key-value pairs and preserve insertion order.

---

## What does the expression `bool({})` evaluate to?

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - An empty dictionary evaluates to False.

- âœ… **False**
  - Empty collections evaluate to False in a boolean context.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and evaluates to False.

### Explanation:
Empty collections such as lists, dictionaries, and sets evaluate to False.

---

## What does the expression `sorted([3, 1, 2])` return?

**Domain:** Data Aggregates

### Options:
- âŒ **[3, 1, 2]**
  - The function returns a sorted version of the list.

- âœ… **[1, 2, 3]**
  - The sorted() function returns the list in ascending order.

- âŒ **None**
  - The sorted() function returns a new sorted list.

- âŒ **Error**
  - The function executes correctly.

### Explanation:
The `sorted()` function sorts the list in ascending order.

---

## Which of the following statements about Python sets is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Sets allow duplicate values.**
  - Sets automatically remove duplicate values.

- âœ… **Sets are unordered collections.**
  - Sets do not maintain any specific order.

- âŒ **Sets are immutable.**
  - Sets are mutable, but their elements must be immutable.

- âŒ **Sets must contain at least one element.**
  - Sets can be empty.

### Explanation:
Sets are unordered collections that automatically remove duplicates.

---

## What is the expected output of the following code?

print(bool('False'))

**Domain:** Boolean Logic

### Options:
- âŒ **False**
  - Any non-empty string evaluates to True in a boolean context.

- âœ… **True**
  - Since 'False' is a non-empty string, it evaluates to True.

- âŒ **None**
  - The bool() function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
In Python, any non-empty string evaluates to True when passed to the bool() function.

---

## What is the expected output of the following code?

print(2 ** 3 ** 2)

**Domain:** Operators

### Options:
- âŒ **64**
  - The exponentiation operator is right-associative.

- âœ… **512**
  - 3 ** 2 is evaluated first, then 2 ** 9, which equals 512.

- âŒ **9**
  - Exponentiation is not evaluated left-to-right.

- âŒ **Error**
  - The code is valid and executes correctly.

### Explanation:
Python's ** operator follows right-to-left associativity, leading to 2 ** (3 ** 2) = 512.

---

## What will be the output of the following code?

x = 5
y = x > 3 and x < 10
print(y)

**Domain:** Boolean Logic

### Options:
- âœ… **True**
  - Both conditions are True, so the final result is True.

- âŒ **False**
  - Both comparisons evaluate to True.

- âŒ **None**
  - The expression evaluates to a boolean value, not None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
Logical AND returns True if both conditions evaluate to True.

---

## Which of the following statements about Python loops is true?

**Domain:** Control Flow

### Options:
- âŒ **A for loop can only iterate over lists.**
  - For loops can iterate over any iterable, including tuples and strings.

- âœ… **A while loop runs until a specified condition is False.**
  - While loops continue executing as long as the condition remains True.

- âŒ **Break statements do not work in loops.**
  - Break statements terminate loops early.

- âŒ **Continue statements exit the loop.**
  - Continue statements skip the current iteration but do not exit the loop.

### Explanation:
While loops execute as long as a condition remains True.

---

## What does the expression `bool('')` evaluate to?

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - An empty string evaluates to False in a boolean context.

- âœ… **False**
  - Empty strings evaluate to False when converted to a boolean.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and executes correctly.

### Explanation:
Empty strings evaluate to False when converted to a boolean.

---

## Which of the following statements about Python strings is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Strings are mutable.**
  - Strings in Python are immutable.

- âœ… **Strings can be indexed and sliced.**
  - Python allows indexing and slicing of string elements.

- âŒ **Strings must always be lowercase.**
  - Strings can contain uppercase, lowercase, or mixed-case characters.

- âŒ **Strings are the same as lists.**
  - Strings are sequences, but they are immutable, unlike lists.

### Explanation:
Python strings can be indexed and sliced but are immutable.

---

## What does the following code output?

print(len([[]]))

**Domain:** Data Aggregates

### Options:
- âŒ **0**
  - The list contains one element, which is an empty list.

- âœ… **1**
  - The list contains a single element, an empty list, so its length is 1.

- âŒ **None**
  - The len() function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
len([[]]) returns 1 because the outer list contains one element (an empty list).

---

## What is the expected output of the following code?

print(type({}))

**Domain:** Data Aggregates

### Options:
- âœ… **<class 'dict'>**
  - An empty {} creates an empty dictionary in Python.

- âŒ **<class 'set'>**
  - An empty set is created using `set()`, not `{}`.

- âŒ **Error**
  - The code executes correctly.

- âŒ **None**
  - The type() function returns the type, not None.

### Explanation:
An empty `{}` in Python represents an empty dictionary.

---

## Which of the following statements about Python lists is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Lists must contain elements of the same type.**
  - Lists can contain elements of different types.

- âŒ **Lists are immutable.**
  - Lists are mutable and can be modified.

- âœ… **Lists are ordered collections.**
  - Lists maintain the order of their elements.

- âŒ **Lists do not support indexing.**
  - Lists support indexing and slicing.

### Explanation:
Lists are ordered collections and maintain the order of elements.

---

## What does the expression `bool(None)` evaluate to?

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - None evaluates to False in a boolean context.

- âœ… **False**
  - None is considered a falsy value in Python.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and evaluates to False.

### Explanation:
None evaluates to False when converted to a boolean.

---

## What is the output of the following code?

print(len({'a': 1, 'b': 2, 'c': 3}))

**Domain:** Data Aggregates

### Options:
- âŒ **2**
  - The dictionary contains three key-value pairs.

- âœ… **3**
  - The length of a dictionary is determined by the number of keys.

- âŒ **None**
  - The len() function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
The len() function returns the number of key-value pairs in a dictionary.

---

## What is the expected output of the following code?

print(bool([]))

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - Empty lists evaluate to False in a boolean context.

- âœ… **False**
  - Empty collections such as lists evaluate to False.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
Empty collections, including lists, evaluate to False when converted to a boolean.

---

## What is the output of the following code?

print(len('Hello'))

**Domain:** Data Aggregates

### Options:
- âŒ **4**
  - The string contains 5 characters.

- âœ… **5**
  - The len() function counts the number of characters in the string.

- âŒ **None**
  - The len() function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
The len() function returns the number of characters in a string.

---

## What is the expected output of the following code?

x = 'abc'
print(x * 3)

**Domain:** Operators

### Options:
- âœ… **abcabcabc**
  - String multiplication repeats the string the specified number of times.

- âŒ **Error**
  - String multiplication is a valid operation in Python.

- âŒ **3abc**
  - The number must be on the right side to repeat the string.

- âŒ **'abc' 'abc' 'abc'**
  - Multiplication does not insert spaces between repetitions.

### Explanation:
Multiplying a string by a number repeats the string that many times.

---

## What does the following code print?

print(type([]))

**Domain:** Data Aggregates

### Options:
- âœ… **<class 'list'>**
  - An empty [] represents an empty list in Python.

- âŒ **<class 'dict'>**
  - {} represents an empty dictionary, not a list.

- âŒ **Error**
  - The code executes correctly.

- âŒ **None**
  - The type() function returns the type, not None.

### Explanation:
The square brackets [] in Python denote an empty list.

---

## Which of the following statements about Python sets is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Sets allow duplicate values.**
  - Sets automatically remove duplicate values.

- âœ… **Sets are unordered collections.**
  - Sets do not maintain any specific order.

- âŒ **Sets are immutable.**
  - Sets are mutable, but their elements must be immutable.

- âŒ **Sets must contain at least one element.**
  - Sets can be empty.

### Explanation:
Sets are unordered collections that automatically remove duplicates.

---

## What will be the output of the following code?

print(bool(0))

**Domain:** Boolean Logic

### Options:
- âŒ **True**
  - Zero evaluates to False in a boolean context.

- âœ… **False**
  - Numbers other than zero evaluate to True, but zero evaluates to False.

- âŒ **None**
  - The bool() function does not return None.

- âŒ **Error**
  - The code executes correctly.

### Explanation:
The integer 0 evaluates to False in a boolean context.

---

## Which of the following statements about Python dictionaries is true?

**Domain:** Data Aggregates

### Options:
- âŒ **Dictionary keys must be integers.**
  - Keys can be any immutable data type.

- âœ… **Dictionaries preserve the insertion order of elements.**
  - Since Python 3.7, dictionaries maintain insertion order.

- âŒ **Dictionaries allow duplicate keys.**
  - Each key in a dictionary must be unique.

- âŒ **Dictionaries are immutable.**
  - Dictionaries are mutable and can be modified.

### Explanation:
Dictionaries maintain key-value pairs and preserve insertion order.

---

## What does the expression `bool(1)` evaluate to?

**Domain:** Boolean Logic

### Options:
- âœ… **True**
  - All non-zero numbers evaluate to True in a boolean context.

- âŒ **False**
  - Only zero evaluates to False.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and executes correctly.

### Explanation:
Any nonzero number evaluates to True when converted to a boolean.

---

## What does the following code print?

print(type(set()))

**Domain:** Data Aggregates

### Options:
- âœ… **<class 'set'>**
  - Calling set() creates an empty set.

- âŒ **<class 'dict'>**
  - {} creates an empty dictionary, not a set.

- âŒ **Error**
  - The code executes correctly.

- âŒ **None**
  - The type() function returns the type, not None.

### Explanation:
Calling set() explicitly creates an empty set.

---

## What does the expression `bool(-1)` evaluate to?

**Domain:** Boolean Logic

### Options:
- âœ… **True**
  - Any nonzero number evaluates to True in a boolean context.

- âŒ **False**
  - Only zero evaluates to False.

- âŒ **None**
  - The bool function does not return None.

- âŒ **Error**
  - The expression is valid and executes correctly.

### Explanation:
Negative numbers also evaluate to True when converted to a boolean.

---

## A function definition:

**Domain:** Functions

### Options:
- âœ… **must be placed before the first invocation**
  - In Python, a function definition must be placed before the first invocation of that function.

- âŒ **may be placed anywhere inside the code after the first invocation**
  - Functions must be defined before they are called to avoid a NameError.

- âŒ **cannot be placed among other code**
  - Functions can be placed among other code, as long as they are defined before use.

### Explanation:
Python executes code sequentially, so a function must be defined before it is called.

---

## A code point is:

**Domain:** Basics

### Options:
- âœ… **A number which makes up a character.**
  - A code point represents a character in the Unicode character set.

- âŒ **A code containing a point.**
  - A code point is not a code containing a point; rather, it is a numerical value.

- âŒ **A point used to write a code.**
  - This statement does not correctly define a code point.

### Explanation:
A code point is a numerical representation of a character in Unicode.

---

## How many stars will the following code output?

```python
n = 1
if n == 1:
    print('*')
if n == True:
    print('**')
if n == False:
    print('***')
```

**Domain:** Control Flow

### Options:
- âœ… **three**
  - Since n == 1 is True and n == True is also True, both if blocks execute.

- âŒ **two**
  - Both the first and second if blocks execute, printing three stars in total.

- âŒ **one**
  - More than one star is printed.

- âŒ **six**
  - The program does not print six stars.

### Explanation:
Python treats 1 as equivalent to True in boolean comparisons.

---

## How many stars will the following code print?

```python
i = 0
while i <= 5:
    i += 1
    if i % 2 == 0:
        break
    print('*')
```

**Domain:** Control Flow

### Options:
- âŒ **zero**
  - The loop executes at least once before breaking.

- âŒ **three**
  - The loop does not reach three iterations before breaking.

- âŒ **two**
  - The loop does not reach two iterations before breaking.

- âœ… **one**
  - The loop prints one star before breaking when i reaches 2.

### Explanation:
The loop prints one star before encountering the break condition.

---

## What is the expected output of the following code?

```python
def fun(n):
    n **= n
    return n
print(fun(3))
```

**Domain:** Functions

### Options:
- âŒ **The program will cause an error**
  - The syntax is correct, and the function executes properly.

- âŒ **3**
  - The function raises n to the power of itself, not returning n as is.

- âŒ **9**
  - The function calculates `3 ** 3`, which is not 9.

- âœ… **27**
  - The function computes `3 ** 3`, which evaluates to 27.

### Explanation:
The `**` operator performs exponentiation, so `3 ** 3` results in 27.

---

## The ** operator:

**Domain:** Operators

### Options:
- âŒ **does not exist**
  - The ** operator exists in Python.

- âŒ **performs duplicated multiplication**
  - The ** operator does not perform duplicated multiplication.

- âŒ **performs floating-point multiplication**
  - The ** operator is for exponentiation, not multiplication.

- âœ… **performs exponentiation**
  - The ** operator raises the left operand to the power of the right operand.

### Explanation:
The ** operator is used for exponentiation in Python.

---

## What is the expected output of the following code?

```python
data = set([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
print(len(data))
```

**Domain:** Data Aggregates

### Options:
- âŒ **0**
  - The set is not empty.

- âŒ **3**
  - The set contains four unique elements.

- âŒ **10**
  - The set automatically removes duplicates.

- âœ… **4**
  - The set contains the unique elements {1, 2, 3, 4}, so its length is 4.

### Explanation:
Sets automatically remove duplicate values, keeping only unique elements.

---

## What is the decimal value of the following binary number?

1010

**Domain:** Data Types

### Options:
- âŒ **4**
  - 1010 in binary is not 4 in decimal.

- âŒ **8**
  - 1010 in binary is not 8 in decimal.

- âŒ **12**
  - 1010 in binary is not 12 in decimal.

- âœ… **10**
  - 1010 in binary represents 10 in decimal.

### Explanation:
Binary numbers use base 2, where 1010 equals (1*2^3 + 0*2^2 + 1*2^1 + 0*2^0) = 10.

---

## Which of the following variable names is illegal?

**Domain:** Basics

### Options:
- âŒ **tRUE**
  - Python is case-sensitive, so `tRUE` is allowed.

- âŒ **TRUE**
  - While `TRUE` is allowed, `True` (capitalized correctly) is a reserved keyword.

- âŒ **true**
  - Python is case-sensitive, and `true` is allowed as a variable name.

- âœ… **True**
  - True is a reserved keyword and cannot be used as a variable name.

### Explanation:
Python is case-sensitive, but certain reserved keywords, such as `True`, cannot be redefined.

---

## What is the expected output of the following code?

```python
print('Peter' 'Wellert')
```

**Domain:** Data Types

### Options:
- âœ… **PeterWellert**
  - Adjacent string literals are automatically concatenated in Python.

- âŒ **Wellert**
  - The first string is not removed.

- âŒ **The code is erroneous.**
  - Python allows adjacent string literals to be concatenated.

- âŒ **Peter**
  - Both string literals are concatenated into one.

### Explanation:
In Python, adjacent string literals are automatically concatenated.

---

## How many stars will the following code print to the monitor?

```python
x = 1
while x < 10:
    print('*')
    x = x << 1
```

**Domain:** Control Flow

### Options:
- âŒ **one**
  - The loop prints a star in each iteration until x is no longer less than 10.

- âœ… **four**
  - The loop prints a star each time x is doubled: 1, 2, 4, 8. After shifting left to 16, the loop exits.

- âŒ **two**
  - The loop continues until x reaches 10, printing four stars.

- âŒ **eight**
  - The loop stops at four iterations.

### Explanation:
Each iteration doubles `x`, resulting in four iterations before `x` becomes 16 and exits the loop.

---

## You develop a Python application for your company. A list named `employees` contains 200 employee names, the last five being company management. You need to slice the list to display all employees excluding management. Which code segments can you use? Choose two.

**Domain:** Data Aggregates

### Options:
- âŒ **employees[0:-4]**
  - This removes only four elements, leaving one manager in the list.

- âŒ **employees[1:-4]**
  - This removes four elements but also excludes the first employee.

- âŒ **employees[1:-5]**
  - This removes the first employee as well as the five managers.

- âœ… **employees[0:-5]**
  - This removes exactly the last five elements, leaving all non-managers.

- âœ… **employees[:-5]**
  - The default start index (0) removes only the last five elements, which are the managers.

### Explanation:
Using negative slicing removes a set number of elements from the end of the list.

---

## What is the expected output of the following code?

```python
data = 'abbabadaadbbaccabc'
print(data.count('ab', 1))
```

**Domain:** Data Types

### Options:
- âŒ **4**
  - The count does not include the 'ab' at index 0.

- âŒ **3**
  - Only two occurrences of 'ab' exist starting from index 1.

- âŒ **5**
  - The count function only finds two matches from index 1.

- âœ… **2**
  - There are exactly two instances of 'ab' starting from index 1.

### Explanation:
The `count()` method starts searching from index 1 and finds only two occurrences.

---

## What is the expected output of the following code?

```python
data = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
]
for i in range(0, 4):
    print(data[i].pop(), end=' ')
```

**Domain:** Data Aggregates

### Options:
- âŒ **1 5 9 13**
  - This would happen if `.pop(0)` was used instead of `.pop()`.

- âŒ **1 2 3 4**
  - This would be correct if we printed the first element of each sublist instead of popping.

- âŒ **13 14 15 16**
  - This would occur if we accessed the last row instead of popping from all rows.

- âœ… **4 8 12 16**
  - Each `.pop()` removes and prints the last element from each row.

### Explanation:
The `.pop()` method removes and returns the last element of each list.

---

## What is the expected output of the following code?

```python
print('Peter' 'Wellert')
```

**Domain:** Data Types

### Options:
- âœ… **PeterWellert**
  - Adjacent string literals are automatically concatenated in Python.

- âŒ **Wellert**
  - Both strings are concatenated; the first part is not omitted.

- âŒ **The code is erroneous.**
  - Python allows adjacent string literals to be automatically joined.

- âŒ **Peter**
  - Both string literals are concatenated into one.

### Explanation:
In Python, adjacent string literals without an operator are automatically joined.

---

## Which of the following variable names is illegal?

**Domain:** Basics

### Options:
- âŒ **tRUE**
  - Python is case-sensitive, so `tRUE` is a valid identifier.

- âŒ **TRUE**
  - Python allows `TRUE` because it is not a reserved keyword.

- âŒ **true**
  - `true` is a valid variable name in Python.

- âœ… **True**
  - `True` is a reserved keyword and cannot be used as a variable name.

### Explanation:
Python is case-sensitive, but certain reserved keywords cannot be redefined.

---

## What is the expected output of the following code?

```python
i = 0
while i < i + 2:
    i += 1
    print('*')
else:
    print('*')
```

**Domain:** Control Flow

### Options:
- âŒ **zero**
  - The loop does not terminate immediately.

- âŒ **one**
  - The loop executes continuously.

- âŒ **two**
  - The loop does not stop at two iterations.

- âœ… **The snippet will enter an infinite loop.**
  - Since `i < i + 2` is always true, the loop never terminates.

### Explanation:
The loop condition is always true, leading to an infinite loop.

---

## What is the expected output of the following code?

```python
x = 1 + 1 // 2 + 1 / 2 + 2
print(x)
```

**Domain:** Operators

### Options:
- âŒ **4**
  - The result is not an integer.

- âŒ **3**
  - The operations result in a floating-point value, not an integer.

- âœ… **3.5**
  - The expression evaluates to `1 + 0 + 0.5 + 2 = 3.5`.

- âŒ **4.0**
  - The result is 3.5, not 4.0.

### Explanation:
Python follows operator precedence rules, leading to a result of 3.5.

---

## What is the expected output of the following code?

```python
data = set([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
print(len(data))
```

**Domain:** Data Aggregates

### Options:
- âŒ **0**
  - The set is not empty; it contains unique values.

- âŒ **3**
  - The set contains 4 unique elements, not 3.

- âŒ **10**
  - The set removes duplicates, leaving only 4 elements.

- âœ… **4**
  - The set `{1, 2, 3, 4}` has four unique elements.

- âŒ **1**
  - The set contains multiple unique values, not just one.

- âŒ **2**
  - The set has four unique elements, not two.

### Explanation:
Sets automatically remove duplicate values, leaving only unique elements.

---

## What is the decimal value of the following binary number?

`1010`

**Domain:** Data Types

### Options:
- âŒ **4**
  - Binary `1010` converts to decimal 10, not 4.

- âŒ **8**
  - The leftmost bit represents `2^3`, contributing to a total of 10, not 8.

- âŒ **12**
  - The conversion gives 10, not 12.

- âœ… **10**
  - Binary `1010` is calculated as `1Ã—2^3 + 0Ã—2^2 + 1Ã—2^1 + 0Ã—2^0 = 8 + 0 + 2 + 0 = 10`.

### Explanation:
Binary numbers are converted to decimal using powers of 2.

---

## What is the expected output of the following code?

```python
a = [1, 2, 3, 4, 5]
print(a[3:0:-1])
```

**Domain:** Data Aggregates

### Options:
- âŒ **The code is erroneous.**
  - The syntax is correct and executes without errors.

- âŒ **[4, 3, 2, 1]**
  - The slicing excludes index `0`, so `1` is not included.

- âŒ **[4, 3]**
  - The slicing includes more than just `[4, 3]`.

- âœ… **[4, 3, 2]**
  - The slice starts at index 3 (`4`) and moves backwards, excluding index 0.

### Explanation:
The slice `[3:0:-1]` starts at index 3 (`4`), moves backwards, and stops before index 0.

---

## Which of the following items are present in the function header?

**Domain:** Functions

### Options:
- âŒ **return value**
  - The return value is specified in the function body, not the header.

- âœ… **function name and parameter list**
  - A function header includes the function name and a parameter list.

- âŒ **parameter list**
  - While the parameter list is present, it is only part of the function header.

- âŒ **function name**
  - The function name is part of the header, but it must also include parameters.

### Explanation:
A function header consists of the function name followed by parentheses containing the parameter list.

---

## How many stars will the following code print to the monitor?

```python
x = 1
while x < 10:
    print('*')
    x = x << 1
```

**Domain:** Control Flow

### Options:
- âŒ **one**
  - The loop executes multiple times, not just once.

- âœ… **four**
  - The loop runs while `x` is less than 10, iterating four times (`1, 2, 4, 8`).

- âŒ **two**
  - The loop runs more than twice.

- âŒ **eight**
  - The loop exits before reaching eight iterations.

### Explanation:
The left shift operator (`<<`) doubles `x` each iteration, leading to four loops before exiting.

---

## What is the expected output of the following code?

```python
i = 0
while i < i + 2:
    i += 1
    print('*')
else:
    print('*')
```

**Domain:** Control Flow

### Options:
- âŒ **zero**
  - The loop executes indefinitely.

- âŒ **one**
  - The condition ensures the loop never terminates.

- âŒ **two**
  - The loop does not stop after two iterations.

- âœ… **The snippet will enter an infinite loop.**
  - Since `i < i + 2` is always true, the loop never exits.

### Explanation:
The loop condition never becomes false, leading to an infinite loop.

---

## What is the expected output of the following code?

```python
x = 1 + 1 // 2 + 1 / 2 + 2
print(x)
```

**Domain:** Operators

### Options:
- âŒ **4**
  - The expression evaluates to a float, not an integer.

- âŒ **3**
  - The floating-point division results in a decimal value.

- âœ… **3.5**
  - The expression evaluates as `1 + 0 + 0.5 + 2 = 3.5`.

- âŒ **4.0**
  - The correct result is `3.5`, not `4.0`.

### Explanation:
Python follows operator precedence, and division operations produce a floating-point result.

---

## What is the expected output of the following code?

```python
x = '\\'
print(len(x))
```

**Domain:** Basics

### Options:
- âŒ **4**
  - The string `x` consists of two backslashes, so its length is 2, not 4.

- âŒ **1**
  - The string `x` consists of two backslashes, so its length is 2, not 1.

- âœ… **2**
  - The string `x` is `\\`, which represents two backslashes, making its length 2.

- âŒ **The code is erroneous.**
  - The code is correct and executes without errors.

### Explanation:
The backslash (`\`) is an escape character in Python, so `\\` represents two actual backslashes in the string.

---

## Which of the following variable names are illegal and will cause the SyntaxError exception?

(Select two answers)

**Domain:** Basics

### Options:
- âŒ **print**
  - Although `print` is a built-in function, it can be reassigned as a variable name without causing a SyntaxError.

- âœ… **in**
  - `in` is a reserved keyword in Python and cannot be used as a variable name.

- âŒ **In**
  - `In` is not a reserved keyword in Python. Python is case-sensitive, so `In` is different from `in`.

- âœ… **for**
  - `for` is a reserved keyword in Python and cannot be used as a variable name.

### Explanation:
Reserved keywords in Python cannot be used as variable names.

---

## What is the expected output of the following code?

```python
data = {'1': '0', '0': '1'}
for d in data.vals():
    print(d, end=' ')
```

**Domain:** Data Aggregates

### Options:
- âŒ **0 1**
  - The code will raise an error due to the incorrect method call `vals()`.

- âŒ **1 0**
  - The code will raise an error due to the incorrect method call `vals()`.

- âœ… **The code is erroneous.**
  - The method `vals()` does not exist in Python; the correct method is `values()`.

- âŒ **0 0**
  - The code will not execute successfully due to the incorrect method call.

### Explanation:
The correct method to retrieve values from a dictionary is `values()`, not `vals()`.

---

## What is the expected output of the following code?

```python
data = [[0, 1, 2, 3] for i in range(2)]
print(data[2][0])
```

**Domain:** Data Aggregates

### Options:
- âœ… **The code is erroneous.**
  - The list `data` has only two elements (`data[0]` and `data[1]`), so accessing `data[2]` causes an IndexError.

- âŒ **0**
  - The code does not successfully access `data[2]` as it does not exist.

- âŒ **1**
  - The code does not successfully access `data[2]` as it does not exist.

- âŒ **2**
  - The code does not successfully access `data[2]` as it does not exist.

### Explanation:
The `range(2)` in the list comprehension means `data` contains only two lists (`data[0]` and `data[1]`). Accessing `data[2]` results in an IndexError.

---

## A function definition:

**Domain:** Functions

### Options:
- âœ… **must be placed before the first invocation**
  - Python executes code sequentially, so a function must be defined before it is called.

- âŒ **may be placed anywhere inside the code after the first invocation**
  - Python requires a function to be defined before it is used, otherwise a NameError occurs.

- âŒ **cannot be placed among other code**
  - A function definition can be placed among other code as long as it is defined before being called.

### Explanation:
Functions must be defined before they are used in Python, as the interpreter processes code line by line.

---

## A code point is:

**Domain:** Basics

### Options:
- âœ… **A number which makes up a character.**
  - A code point is a numerical value assigned to a character in Unicode.

- âŒ **A code containing a point.**
  - This is an incorrect definition of a code point.

- âŒ **A point used to write a code.**
  - A code point is not a punctuation mark but a number representing a character.

### Explanation:
A code point is a numerical representation of a character in Unicode.

---

## Which of the following variable names is illegal?

**Domain:** Basics

### Options:
- âŒ **tRUE**
  - Python is case-sensitive, so `tRUE` is a valid variable name.

- âŒ **TRUE**
  - `TRUE` is not a reserved keyword in Python, so it can be used as a variable name.

- âŒ **true**
  - `true` is not a reserved keyword in Python and can be used as a variable name.

- âœ… **True**
  - `True` is a reserved keyword in Python and cannot be used as a variable name.

### Explanation:
Python reserves certain keywords like `True`, `False`, and `None`, which cannot be used as variable names.

---

## The ** operator:

**Domain:** Operators

### Options:
- âŒ **does not exist**
  - The `**` operator exists in Python and is used for exponentiation.

- âŒ **performs duplicated multiplication**
  - The `**` operator performs exponentiation, not repeated multiplication.

- âŒ **performs floating-point multiplication**
  - The `**` operator performs exponentiation, not floating-point multiplication.

- âœ… **performs exponentiation**
  - The `**` operator raises the left operand to the power of the right operand.

### Explanation:
Python's `**` operator is used to perform exponentiation.

---

## What is the expected output of the following code?

```python
data = [1, 2, 3, 4, 5, 6]
for i in range(1, 6):
    data[i - 1] = data[i]
for i in range(0, 6):
    print(data[i], end=' ')
```

**Domain:** Data Aggregates

### Options:
- âœ… **2 3 4 5 6 6**
  - The code shifts each element left by one position, and the last element remains unchanged.

- âŒ **1 2 3 4 5 6**
  - The first element gets replaced by the second, and so forth, modifying the list.

- âŒ **1 1 2 3 4 5**
  - The shift operation does not duplicate the first element.

- âŒ **2 3 4 5 6 1**
  - The last element remains unchanged; it does not wrap around.

### Explanation:
The loop shifts elements left by one position, leaving the last element unchanged.

---

## The unnamed except block ...

**Domain:** Error Handling

### Options:
- âŒ **can be placed anywhere.**
  - The unnamed except block must be the last one in the sequence of except blocks.

- âŒ **cannot be used if any named block has been used.**
  - It can be used with named blocks, but it must be placed last.

- âŒ **must be the first one.**
  - If the unnamed except block comes first, it will catch all exceptions before named blocks.

- âœ… **must be the last one.**
  - The unnamed except block must be the last in an exception handling sequence.

### Explanation:
In Python, the generic `except:` block must be the last in the try-except sequence.

---

## Only one of the following statements is true - which one?

**Domain:** Operators

### Options:
- âœ… **multiplication precedes addition**
  - Multiplication has a higher precedence than addition in Python.

- âŒ **neither statement can be evaluated**
  - Python operator precedence is well defined.

- âŒ **addition precedes multiplication**
  - Addition has lower precedence than multiplication.

### Explanation:
Python follows standard mathematical precedence where multiplication comes before addition.

---

## What is the expected output of the following code?

```python
print(1 / 1)
```

**Domain:** Operators

### Options:
- âœ… **1.0**
  - The division operator (`/`) always returns a float in Python.

- âŒ **1**
  - Integer division (`//`) returns an integer, but `/` always returns a float.

- âŒ **This cannot be predicted.**
  - Python's division rules are well defined.

- âŒ **This cannot be evaluated.**
  - The expression is valid and evaluates to `1.0`.

### Explanation:
Pythonâ€™s `/` operator always returns a float, even for `1 / 1`.

---

## Consider the following code.

```python
x = 1
x = x == x
```

The value eventually assigned to x is equal to:

**Domain:** Operators

### Options:
- âŒ **1**
  - The comparison `x == x` results in `True`, not `1`.

- âŒ **False**
  - `x == x` always evaluates to `True`.

- âŒ **0**
  - The result is a boolean, not an integer.

- âœ… **True**
  - The expression `x == x` evaluates to `True`, and `x` is assigned that value.

### Explanation:
A boolean comparison assigns `True` or `False`, not a numeric value.

---

## What is the output of the following code?

```python
try:
    value = input("Enter a value: ")
    print(value/value)
except ValueError:
    print("Bad input...")
except ZeroDivisionError:
    print("Very bad input...")
except TypeError:
    print("Very very bad input...")
except:
    print("Booo!")
```

**Domain:** Error Handling

### Options:
- âŒ **Bad input...**
  - The error occurs because `value` is a string, causing a `TypeError`, not a `ValueError`.

- âœ… **Very very bad input...**
  - The `TypeError` occurs when attempting to divide a string by itself.

- âŒ **Booo!**
  - A `TypeError` is explicitly handled, so the generic except block is not executed.

- âŒ **Very bad input...**
  - ZeroDivisionError does not occur in this case.

### Explanation:
The division operation fails because `input()` returns a string, causing a `TypeError`.

---

## Take a look at the snippet and choose one of the following statements which is true:

```python
nums = []
vals = nums[:]
vals.append(1)
```

**Domain:** Data Aggregates

### Options:
- âŒ **nums and vals are of the same length**
  - `vals` is a copy of `nums`, but `vals.append(1)` modifies only `vals`.

- âŒ **nums is longer than vals**
  - No elements are added to `nums`, so it remains empty.

- âœ… **vals is longer than nums**
  - `vals` contains one extra element due to `vals.append(1)`.

### Explanation:
Slicing `nums[:]` creates a new list; appending to `vals` does not affect `nums`.

---

## What is the expected output of the following code?

```python
numbers = [1, 2, 3, 4, 5]
nums = numbers[2: ]
print(nums)
```

**Domain:** Data Aggregates

### Options:
- âŒ **[2]**
  - Index `2` corresponds to `3`, not `2`.

- âŒ **[2, 3, 4, 5]**
  - The slice starts from index 2, which is `3`, not `2`.

- âœ… **[3, 4, 5]**
  - Slicing from index 2 to the end results in `[3, 4, 5]`.

- âŒ **The program will cause an error**
  - The slice operation is valid in Python.

### Explanation:
List slicing `numbers[2:]` returns all elements from index 2 onwards.

---

## Which of the following lines properly starts a function using two parameters, both with zeroed default values?

**Domain:** Functions

### Options:
- âŒ **fun fun(a, b=0):**
  - The `def` keyword is missing.

- âŒ **def fun(a=b=0):**
  - Invalid syntax; each parameter must be assigned a default value separately.

- âŒ **fun fun(a=0, b):**
  - Parameters with default values must be placed after those without default values.

- âœ… **def fun(a=0, b=0):**
  - This is the correct way to define a function with default values.

### Explanation:
Python requires parameters with default values to come after parameters without defaults.

---

## The += operator, when applied to strings, performs:

**Domain:** Operators

### Options:
- âœ… **Concatenation**
  - The += operator, when applied to strings, appends the right operand to the left operand, effectively concatenating them.

- âŒ **Multiplication**
  - Multiplication for strings is performed using the * operator, not +=.

- âŒ **Subtraction**
  - Strings do not support subtraction in Python.

### Explanation:
The += operator concatenates strings by appending the right operand to the left operand.

---

## What is the expected output of the following code?

```python
print(chr(ord('z') - 2))
```

**Domain:** Data Types

### Options:
- âŒ **a**
  - The ASCII code of 'z' is 122. Subtracting 2 results in 120, which corresponds to 'x'.

- âœ… **x**
  - ord('z') returns 122. Subtracting 2 results in 120, which is 'x'.

- âŒ **z**
  - The code modifies 'z' by subtracting 2, so the result is not 'z'.

- âŒ **y**
  - Subtracting 2 from 'z' gives 'x', not 'y'.

### Explanation:
The `ord()` function converts characters to ASCII codes, and `chr()` converts them back.

---

## What is the expected output of the following code?

```python
x = """
"""
print(len(x))
```

**Domain:** Basics

### Options:
- âŒ **2**
  - The length of the string is 1, as it contains only a newline character.

- âŒ **The code is erroneous.**
  - The code is valid and does not raise an error.

- âŒ **0**
  - The string contains a newline character, so its length is not 0.

- âœ… **1**
  - The triple-quoted string contains a single newline character, so its length is 1.

### Explanation:
A multiline string with only line breaks has a length equal to the number of newline characters.

---

## What is the expected output of the following code?

```python
x = 9
y = 12
result = x // 2 * 2 / 2 + y % 2 ** 3
print(result)
```

**Domain:** Operators

### Options:
- âŒ **7.0**
  - The correct result of the calculation is 8.0.

- âœ… **8.0**
  - Operator precedence ensures the operations evaluate to 8.0.

- âŒ **8**
  - The result is a float due to the division operation.

- âŒ **9.0**
  - The correct result of the calculation is 8.0.

### Explanation:
Python follows operator precedence rules, leading to an output of 8.0.

---

## How did Python, the programming language, get its name?

**Domain:** Basics

### Options:
- âŒ **Guido van Rossum named it to honor Python of Catana, a dramatic poet of the time of Alexander the Great**
  - Python is not named after an ancient poet.

- âŒ **Guido van Rossum named it after the Pythonidae - a family of large, nonvenomous snakes**
  - While Python is associated with snakes, its name originates from a comedy show.

- âœ… **Guido van Rossum named it to honor Monty Python's Flying Circus, a BBC comedy series popular in the 1970s**
  - Guido van Rossum named Python after Monty Pythonâ€™s Flying Circus.

### Explanation:
Python was named after a British comedy series, not the snake.

---

## Which of the following lines properly starts a function using two parameters, both with zeroed default values?

**Domain:** Functions

### Options:
- âŒ **fun fun(a, b=0):**
  - The function definition is missing the `def` keyword.

- âŒ **def fun(a=b=0):**
  - This syntax is invalid; each parameter must be assigned separately.

- âŒ **fun fun(a=0, b):**
  - Parameters with default values must be at the end of the parameter list.

- âœ… **def fun(a=0, b=0):**
  - This correctly defines a function with two parameters, both having default values.

### Explanation:
Python requires parameters with default values to be placed at the end.

---

## What is the expected output of the following code?

```python
data = [1, {}, (2,), (), {3}, [4, 5]]
points = 0

for i in range(len(data)):
    if type(data[i]) == list:
        points += 1
    elif type(data[i]) == tuple:
        points += 10
    elif type(data[i]) == set:
        points += 100
    elif type(data[i]) == dict:
        points += 1000
    else:
        points += 10000

print(points)
```

**Domain:** Control Flow

### Options:
- âŒ **10221**
  - The expected calculation results in 11121, not 10221.

- âœ… **11121**
  - Each type in the list contributes to the score based on the defined conditions.

- âŒ **10212**
  - The calculation results in 11121, not 10212.

- âŒ **11112**
  - The calculation results in 11121, not 11112.

- âŒ **21102**
  - The calculation results in 11121, not 21102.

### Explanation:
Each element's type determines how many points get added.

---

## What is the expected output of the following code?

```python
data = (1,) * 3
data[0] = 2
print(data)
```

**Domain:** Data Aggregates

### Options:
- âŒ **(2, 2, 2)**
  - Tuples are immutable, so their values cannot be modified.

- âœ… **The code is erroneous.**
  - Tuples do not allow element reassignment, resulting in a TypeError.

- âŒ **(2, 1, 1)**
  - The modification attempt will fail before this result can be achieved.

- âŒ **(1, 1, 1)**
  - The tuple remains unchanged, but the modification attempt will raise an error.

### Explanation:
Tuples are immutable in Python.

---

## What is the expected output of the following code?

```python
print(2 ** 3 ** 2 ** 1)
```

**Domain:** Operators

### Options:
- âŒ **64**
  - Exponentiation is evaluated from right to left, making the final result 512.

- âŒ **128.0**
  - The correct result is 512, not 128.0.

- âŒ **16.0**
  - The correct result is 512, not 16.

- âŒ **16**
  - The correct result is 512, not 16.

- âŒ **The code is erroneous.**
  - The code executes correctly without errors.

- âœ… **512**
  - Exponentiation is evaluated from right to left, making the final result 512.

### Explanation:
Exponentiation in Python is right-associative.

---

## Which of the following code snippets will print True to the monitor?

**Domain:** Operators

### Options:
- âœ… **print('t' in 'Peter')**
  - The character 't' is in the string 'Peter'.

- âŒ **x = 42
y = 42
print(x is not y)**
  - Since integers are immutable, 42 is the same object in both cases, so 'is not' evaluates to False.

- âŒ **x = ['Peter', 'Paul', 'Mary']
y = ['Peter', 'Paul', 'Mary']
print(x is y)**
  - Even though both lists contain the same elements, they are different objects in memory, so 'is' evaluates to False.

- âŒ **x = 'Peter Wellert'
y = 'Peter Wellert'.lower()
print(x is y)**
  - Lowercasing a string creates a new object, so 'is' evaluates to False.

- âœ… **print('is' in 'This IS Python code.')**
  - The substring 'is' is present in 'This IS Python code.'.

### Explanation:
The 'in' operator checks for membership, while 'is' checks for object identity.

---

## What is the expected output of the following code?

```python
data = (1, 2, 4, 8)
data = data[1:-1]
data = data[0]
print(data)
```

**Domain:** Data Aggregates

### Options:
- âŒ **(2)**
  - The result is an integer, not a tuple.

- âŒ **(2,)**
  - The tuple is sliced and accessed, but the final result is an integer.

- âŒ **The code is erroneous.**
  - The code executes correctly.

- âœ… **2**
  - The slice produces (2,4), and then the first element (2) is assigned.

### Explanation:
Tuple slicing extracts a new tuple, and indexing selects an element.

---

## The folder created by Python used to store pyc files is named:

**Domain:** Basics

### Options:
- âŒ **__cache__**
  - The correct folder is '__pycache__'.

- âœ… **__pycache__**
  - Python stores compiled bytecode files in the '__pycache__' folder.

- âŒ **__pycfiles__**
  - The correct folder is '__pycache__'.

- âŒ **__pyc__**
  - The correct folder is '__pycache__'.

### Explanation:
Python caches compiled files in '__pycache__'.

---

## Right-sided binding means that the following expression

```python
1 ** 2 ** 3
```
will be evaluated:

**Domain:** Operators

### Options:
- âŒ **in random order**
  - Python follows specific precedence rules, so it does not evaluate expressions randomly.

- âœ… **from right to left**
  - Exponentiation in Python follows right-sided binding, meaning it evaluates from right to left.

- âŒ **from left to right**
  - Exponentiation is right-associative, meaning it evaluates from right to left.

### Explanation:
Python evaluates exponentiation expressions from right to left.

---

## What is the expected output of the following code?

```python
data = ()
print(data.__len__())
```

**Domain:** Data Aggregates

### Options:
- âœ… **0**
  - An empty tuple has a length of 0.

- âŒ **None**
  - The '__len__()' method returns an integer, not None.

- âŒ **1**
  - An empty tuple has no elements, so its length is 0.

- âŒ **The code is erroneous.**
  - The code executes correctly.

### Explanation:
Calling '__len__()' on an empty tuple returns 0.

---

## Which of the following code snippets will print True to the monitor?

**Domain:** Operators

### Options:
- âœ… **print('t' in 'Peter')**
  - The character 't' is present in the string 'Peter'.

- âŒ **x = 42
y = 42
print(x is not y)**
  - Since integers are immutable, 42 is the same object in both cases, so 'is not' evaluates to False.

- âŒ **x = ['Peter', 'Paul', 'Mary']
y = ['Peter', 'Paul', 'Mary']
print(x is y)**
  - Even though both lists contain the same elements, they are different objects in memory, so 'is' evaluates to False.

- âŒ **x = 'Peter Wellert'
y = 'Peter Wellert'.lower()
print(x is y)**
  - Lowercasing a string creates a new object, so 'is' evaluates to False.

- âœ… **print('is' in 'This IS Python code.')**
  - The substring 'is' is present in 'This IS Python code.'.

### Explanation:
The 'in' operator checks for membership, while 'is' checks for object identity.

---

## What is the expected output of the following code?

```python
data = (1, 2, 4, 8)
data = data[1:-1]
data = data[0]
print(data)
```

**Domain:** Data Aggregates

### Options:
- âŒ **(2)**
  - The result is an integer, not a tuple.

- âŒ **(2,)**
  - The tuple is sliced and accessed, but the final result is an integer.

- âŒ **The code is erroneous.**
  - The code executes correctly.

- âœ… **2**
  - The slice produces (2,4), and then the first element (2) is assigned.

### Explanation:
Tuple slicing extracts a new tuple, and indexing selects an element.

---

## The folder created by Python used to store pyc files is named:

**Domain:** Basics

### Options:
- âŒ **__cache__**
  - The correct folder is '__pycache__'.

- âœ… **__pycache__**
  - Python stores compiled bytecode files in the '__pycache__' folder.

- âŒ **__pycfiles__**
  - The correct folder is '__pycache__'.

- âŒ **__pyc__**
  - The correct folder is '__pycache__'.

### Explanation:
Python caches compiled files in '__pycache__'.

---

## Right-sided binding means that the following expression

```python
1 ** 2 ** 3
```
will be evaluated:

**Domain:** Operators

### Options:
- âŒ **in random order**
  - Python follows specific precedence rules, so it does not evaluate expressions randomly.

- âœ… **from right to left**
  - Exponentiation in Python follows right-sided binding, meaning it evaluates from right to left.

- âŒ **from left to right**
  - Exponentiation is right-associative, meaning it evaluates from right to left.

### Explanation:
Python evaluates exponentiation expressions from right to left.

---

## What is the expected output of the following code?

```python
data = ()
print(data.__len__())
```

**Domain:** Data Aggregates

### Options:
- âœ… **0**
  - An empty tuple has a length of 0.

- âŒ **None**
  - The '__len__()' method returns an integer, not None.

- âŒ **1**
  - An empty tuple has no elements, so its length is 0.

- âŒ **The code is erroneous.**
  - The code executes correctly.

### Explanation:
Calling '__len__()' on an empty tuple returns 0.

---

## What is the expected output of the following code?

    w = [7, 3, 23, 42]
    x = w[1:]
    y = w[1:]
    z = w
    y[0] = 10
    z[1] = 20
    print(w)

**Domain:** Data Aggregates

### Options:
- âŒ **[7, 3, 23, 42]**
  - This choice is incorrect because it does not consider the modifications made to the list 'w' through the variables 'y' and 'z'.

- âŒ **[10, 20, 23, 42]**
  - This choice is incorrect because it combines the changes made to both 'y' and 'z' but does not consider the original values.

- âœ… **[7, 20, 23, 42]**
  - The expected output includes the modifications made through both 'y' and 'z', resulting in [7, 20, 23, 42].

- âŒ **[10, 20, 42]**
  - This choice is incorrect because it only considers the changes made to the list 'y' and does not account for modifications made through 'z'.

### Explanation:
The two list slicings create new lists, while assigning a list creates a reference to the same object. Therefore, 'y' does not affect 'w', but 'z' does.

---

## Select the true statement about function arguments.

**Domain:** Functions

### Options:
- âŒ **The order of arguments passed does not matter in positional argument passing.**
  - In positional argument passing, the order of arguments passed does matter.

- âœ… **Keyword arguments cannot be followed by positional arguments.**
  - Once a keyword argument is used, all subsequent arguments must also be passed as keyword arguments.

- âŒ **You cannot use a mix of positional and keyword argument passing.**
  - In Python, you can use a mix of positional and keyword arguments as long as positional arguments come first.

- âŒ **The order of arguments passed does matter in keyword argument passing.**
  - In keyword argument passing, arguments are matched based on their names, so order does not matter.

### Explanation:
Python allows mixing positional and keyword arguments, but keyword arguments must come after positional ones.

---

## What is the function of the ** operator in Python?

**Domain:** Operators

### Options:
- âŒ **Performs duplicated multiplication.**
  - The ** operator does not perform duplicated multiplication; it is used for exponentiation.

- âœ… **Performs exponentiation.**
  - The ** operator in Python is used to raise a number to the power of another number.

- âŒ **Performs floating-point multiplication.**
  - The ** operator does not perform floating-point multiplication; it is strictly for exponentiation.

- âŒ **Does not exist.**
  - The ** operator exists and is a built-in Python operator for exponentiation.

### Explanation:
The ** operator is known as the exponentiation operator and is used to raise numbers to a power.

---

## What is the expected output of the following code?

    def func(item):
        item += [1]

    data = [1, 2, 3, 4]
    func(data)
    print(len(data))

**Domain:** Functions

### Options:
- âœ… **5**
  - Lists are mutable, so appending an element inside the function modifies the original list.

- âŒ **2**
  - This choice is incorrect because the function modifies the original list by adding an element to it.

- âŒ **4**
  - This choice is incorrect because the function modifies the original list by adding an element to it.

- âŒ **The code is erroneous.**
  - The code is not erroneous; it correctly modifies the list inside the function.

### Explanation:
In Python, lists are mutable, meaning changes inside a function persist outside of it.

---

## What is the expected output of the following code?

    my_list = [0, 1, 2, 3]
    x = 1
    for elem in my_list:
        x *= elem
    print(x)

**Domain:** Data Aggregates

### Options:
- âœ… **0**
  - Multiplying any number by zero results in zero, making the final output 0.

- âŒ **1**
  - Since the loop multiplies 'x' by each element, including 0, the result will not remain 1.

- âŒ **6**
  - This choice is incorrect because the presence of 0 in the list ensures that the final value will be 0.

### Explanation:
The for loop multiplies each element in the list by 'x', and since the list contains 0, the final result is 0.

---

## Which statement correctly prints each name in the list on a new line?

    data = ['Peter', 'Paul', 'Mary', 'Jane']

**Domain:** Data Types

### Options:
- âŒ **print(data.join(''))**
  - Lists do not have a 'join' method; 'join' is a string method.

- âŒ **print(data.concatenate('
'))**
  - There is no 'concatenate' method for lists in Python.

- âœ… **print('
'.join(data))**
  - The 'join' method is used with a string separator to concatenate list elements with a newline character.

### Explanation:
Using ''.join(data) concatenates the elements with newline characters, effectively printing each name on a new line.

---

## Which one of the following is an example of a Python file extension?

**Domain:** Basics

### Options:
- âŒ **pi**
  - The file extension '.pi' is not a standard Python file extension. Python files should have the '.py' extension to be recognized and executed as Python code.

- âŒ **p**
  - The file extension '.p' is not a standard Python file extension. Python files should have the '.py' extension to be recognized and executed as Python code.

- âœ… **py**
  - The file extension '.py' is the standard file extension for Python files. It is used to indicate that the file contains Python code and should be interpreted by the Python interpreter.

### Explanation:
Python files use the '.py' extension to indicate that they contain Python source code. Other extensions like '.pi' and '.p' are not valid for Python scripts.

---

## How many elements will the following list contain?

```python
data = [i for i in range(-1, 2)]
```

**Domain:** Control Flow

### Options:
- âŒ **two**
  - The list comprehension generates a list with elements from -1 up to (but not including) 2. Since the range includes -1, 0, and 1, the resulting list will contain three elements, not just two.

- âœ… **three**
  - The list comprehension generates a list with elements from -1 up to (but not including) 2. Since the range includes -1, 0, and 1, the resulting list will contain three elements.

- âŒ **one**
  - The list comprehension generates a list with elements from -1 up to (but not including) 2. Since the range includes -1, 0, and 1, the resulting list will contain three elements, not just one.

- âŒ **zero**
  - The list comprehension generates a list with elements from -1 up to (but not including) 2. It includes -1, 0, and 1, so the resulting list will not be empty and will contain three elements, not zero.

- âŒ **four**
  - The list comprehension generates a list with elements from -1 up to (but not including) 2. Since the range includes -1, 0, and 1, the resulting list will contain three elements, not four.

### Explanation:
The `range(-1, 2)` function produces values -1, 0, and 1, which results in a list of three elements. The end value 2 is exclusive, so it is not included.

---

## What is the expected output of the following code?

```python
print(type(1J))
```

**Domain:** Data Types

### Options:
- âŒ **<type 'dict'>**
  - The output is incorrect because the code is not dealing with dictionaries (dict) in this case. The type() function is specifically used to determine the data type of the value passed to it, which in this case is a complex number, not a dictionary.

- âŒ **<type 'unicode'>**
  - The output is incorrect because the code is not dealing with Unicode strings in this case. The type() function correctly identifies the data type as complex, not Unicode.

- âŒ **<type 'float'>**
  - The output is incorrect because the code is not dealing with floating-point numbers (float) in this case. The type() function correctly identifies the data type as complex, not float.

- âœ… **<type 'complex'>**
  - The output is correct because the code is using the type() function to determine the data type of the complex number 1J. In Python, complex numbers are represented by adding a 'J' or 'j' after the imaginary part, and the type() function correctly identifies it as a complex data type.

### Explanation:
Python represents complex numbers using the `complex` type. A number with an imaginary component, like `1J`, is recognized as a complex number.

---

## How many stars will the following snippet print to the monitor?

```python
x = 16
while x > 0:
    print('*')
    x //= 2
```

**Domain:** Control Flow

### Options:
- âŒ **one**
  - The code prints a star (*) in each iteration of the while loop, and the value of x is divided by 2 (`x //= 2`) in each iteration. The loop will run 5 times before x becomes 0, resulting in 5 stars being printed, not one.

- âŒ **three**
  - The code prints a star (*) in each iteration of the while loop, and the value of x is divided by 2 (`x //= 2`) in each iteration. The loop will run 5 times before x becomes 0, resulting in 5 stars being printed, not three.

- âŒ **The code will enter an infinite loop.**
  - The code starts with `x = 16` and prints a star (*) in each iteration of the while loop. The value of x is divided by 2 (`x //= 2`) in each iteration. Since x is an integer, it will eventually reach 0 after 5 iterations, so the code will not enter an infinite loop.

- âœ… **five**
  - The code starts with `x = 16` and prints a star (*) in each iteration of the while loop. The value of x is divided by 2 (`x //= 2`) in each iteration. The loop will run 5 times before x becomes 0, resulting in 5 stars being printed.

### Explanation:
The while loop runs as long as `x > 0`. Each iteration halves `x` using floor division (`x //= 2`). Starting from 16, the loop executes 5 times before `x` becomes 0.

---

## Take a look at the snippet and choose one of the following statements which is true:

```python
nums = []
vals = nums
vals.append(1)
```

**Domain:** Data Aggregates

### Options:
- âŒ **nums is longer than vals**
  - As `vals` is a reference to the list `nums`, appending a value to `vals` will also modify the original list `nums`. Therefore, both `nums` and `vals` will have the same length, and `nums` will not be longer than `vals`.

- âŒ **vals is longer than nums**
  - Since `vals` is a reference to the list `nums`, appending a value to `vals` will also modify the original list `nums`. As a result, both `nums` and `vals` will have the same length, and `vals` will not be longer than `nums`.

- âœ… **nums and vals are of the same length**
  - When the value 1 is appended to the list `vals`, it is also appended to the list `nums` because `vals` is a reference to the same list as `nums`. Therefore, both `nums` and `vals` will have the same length after appending 1.

### Explanation:
Lists in Python are mutable and stored by reference. Assigning `vals = nums` does not create a new list, but instead makes `vals` point to the same list as `nums`. Any modification to `vals` will also reflect in `nums`.

---

## What is the expected output of the following code?

```python
data = {}
data[1] = 1
data['1'] = 2
data[1.0] = 4
 
res = 0
for d in data:
    res += data[d]
 
print(res)
```

**Domain:** Data Aggregates

### Options:
- âœ… **6**
  - The dictionary `data` treats `1` and `1.0` as the same key, so the latest assignment (`1.0: 4`) overrides `1: 1`. The keys in `data` are `{1: 4, '1': 2}` and the sum of their values is `4 + 2 = 6`.

- âŒ **3**
  - The output is 6, not 3. The dictionary keys collapse `1` and `1.0` into a single entry.

- âŒ **The code is erroneous.**
  - The code is valid and executes correctly.

- âŒ **7**
  - The sum of the values in the dictionary is `4 + 2 = 6`, not 7.

### Explanation:
In Python, integer keys and float keys with the same numeric value are treated as the same key in a dictionary. Thus, `1.0` overwrites `1`, resulting in a dictionary with only two entries: `{1: 4, '1': 2}`.

---

## Which of the following operators can be used with strings?

**Domain:** Data Types

### Options:
- âŒ **1, 2, 3, 4**
  - The `+`, `*`, and `in` operators can be used with strings, but `-` is not valid for strings in Python.

- âŒ **1, 2**
  - The `+` and `*` operators work with strings, but `in` also works, so this is incomplete.

- âœ… **1, 2, 4**
  - The `+` operator is for string concatenation, `*` repeats a string, and `in` checks for substring presence.

- âŒ **1, 2, 3**
  - The `-` operator is not valid for strings in Python.

### Explanation:
String operations in Python include `+` for concatenation, `*` for repetition, and `in` for substring checking. However, `-` is not a valid string operator.

---

## What is the output of the following snippet?

```python
l1 = [1, 2, 3]
 
for v in range(len(l1)):
    l1.insert(1, l1[v])
 
print(l1)
```

**Domain:** Data Aggregates

### Options:
- âŒ **[1, 2, 3, 1, 2, 3]**
  - The insert operation always inserts at index 1, shifting the existing elements.

- âœ… **[1, 1, 1, 1, 2, 3]**
  - Each iteration inserts the value at index 1, pushing previous values right. The result is `[1, 1, 1, 1, 2, 3]`.

- âŒ **[3, 2, 1, 1, 2, 3]**
  - The elements are inserted in a different order than this choice suggests.

- âŒ **[1, 2, 3, 3, 2, 1]**
  - This answer does not correctly account for the insertion at index 1.

### Explanation:
The loop repeatedly inserts elements at index 1, shifting the rest to the right, resulting in `[1, 1, 1, 1, 2, 3]`.

---

## What is the expected output of the following code?

```python
box = {}
jars = {}
crates = {}
 
box['biscuit'] = 1
box['cake'] = 3
 
jars['jam'] = 4
 
crates['box'] = box
crates['jars'] = jars
 
print(len(crates[box]))
```

**Domain:** Data Aggregates

### Options:
- âœ… **The code is erroneous.**
  - The code attempts to use `box` as a key in `crates`, but dictionaries are not hashable, causing a `TypeError`.

- âŒ **3**
  - The code does not produce an integer result due to a TypeError.

- âŒ **4**
  - The operation fails before returning any length.

- âŒ **1**
  - The length cannot be determined because the code raises an error.

### Explanation:
Dictionaries cannot be used as keys in other dictionaries since they are mutable and unhashable. Attempting to do so raises a `TypeError`.

---

## What is the expected output of the following code?

```python
print(chr(ord('p') + 3))
```

**Domain:** Data Types

### Options:
- âŒ **r**
  - The ASCII value of 'p' is 112, adding 3 results in 115, which corresponds to 's'.

- âœ… **s**
  - The `ord()` function gets the ASCII value of 'p' (112), adding 3 results in 115, which `chr()` converts to 's'.

- âŒ **t**
  - The ASCII value 115 corresponds to 's', not 't'.

- âŒ **q**
  - The ASCII value 115 corresponds to 's', not 'q'.

### Explanation:
The `ord()` function retrieves the ASCII value of a character, while `chr()` converts a number back into a character.

---

## What is the expected output of the following code?

```python
print(not 0)
print(not 23)
print(not '')
print(not 'Peter')
print(not None)
```

**Domain:** Data Types

### Options:
- âŒ **True, False, True, False, False**
  - `not None` evaluates to `True`, so this is incorrect.

- âœ… **True, False, True, False, True**
  - In Python, `0`, empty strings, and `None` evaluate to `False`, so `not` inverts them to `True`.

- âŒ **False, False, True, False, True**
  - `not 0` evaluates to `True`, so this is incorrect.

- âŒ **True, False, False, False, True**
  - `not ''` evaluates to `True`, so this is incorrect.

### Explanation:
The `not` operator in Python inverts truth values: zero, empty strings, and `None` are considered `False`, so `not` makes them `True`.

---

## Which of the following enclose the input parameters or arguments of a function?

**Domain:** Functions

### Options:
- âŒ **Quotation marks**
  - Quotation marks are used for defining strings, not function parameters.

- âœ… **Parentheses**
  - Function arguments are enclosed in parentheses in Python.

- âŒ **Brackets**
  - Brackets are used for lists and indexing, not function parameters.

- âŒ **Curly braces**
  - Curly braces are used for dictionaries and sets, not function parameters.

### Explanation:
Function arguments in Python are enclosed in parentheses to distinguish them from other elements.

---

## What would you insert instead of ??? so that the program prints TRUE to the monitor?

```python
w = 7
x = 3
y = 4
z = True
a = w + x * y
b = w + x / z
 
if ???:
    print('TRUE')
else:
    print('FALSE')
```

**Domain:** Control Flow

### Options:
- âŒ **a < b**
  - The expression `a < b` checks if `a` is less than `b`, but in this case, `a` is greater than `b`.

- âŒ **a == b**
  - The values of `a` and `b` are not equal, so this condition would evaluate to False.

- âœ… **a > b**
  - The value of `a` is calculated as `7 + 3 * 4 = 19`, and `b` is `7 + 3 / 1 = 10`. Since `a` is greater than `b`, the condition evaluates to True.

- âŒ **a <= b**
  - Since `a` is greater than `b`, this condition would be False, and 'FALSE' would be printed.

### Explanation:
Operator precedence applies here: multiplication happens before addition, affecting `a` and `b`'s values.

---

## What is the expected behavior of the following snippet?

```python
x = 1
 
def a(x):
    return 2 * x
 
x = 2 + a(x)  # Line 8
print(a(x))  # Line 9
```

**Domain:** Functions

### Options:
- âŒ **It will print 6**
  - The final value of `x` will be 4, so `a(x)` will return 8, not 6.

- âŒ **Cause a runtime exception on Line 8**
  - There is no runtime error; the function executes correctly.

- âŒ **Cause a runtime exception on Line 9**
  - The function call is valid and executes properly.

- âœ… **Print 8**
  - `x = 2 + a(x)` calculates `2 + (2 * 1) = 4`, so `a(x)` prints `2 * 4 = 8`.

### Explanation:
The function takes an argument and returns twice its value. The new value of `x` is computed before passing it to `a()`.

---

## What is the expected output of the following code?

```python
data = [[42, 17, 23, 13], [11, 9, 3, 7]]
res = data[0][0]
for da in data:
    for d in da:
        if res > d:
            res = d
print(res)
```

**Domain:** Control Flow

### Options:
- âœ… **3**
  - The code initializes `res` with `42` and iterates over all elements, updating `res` to the smallest value, which is `3`.

- âŒ **The code is erroneous.**
  - The code executes correctly and does not raise any errors.

- âŒ **42**
  - Although `42` is the first element, the loop updates `res` to the smallest value found.

- âŒ **13**
  - The smallest value in the list is `3`, not `13`.

### Explanation:
The nested loop iterates over the matrix and updates `res` whenever a smaller value is found.

---

## What is the expected result of the following code?

```python
try:
    raise Exception
except:
    print('c')
except BaseException:
    print('a')
except Exception:
    print('b')
```

**Domain:** Error Handling

### Options:
- âŒ **b**
  - The incorrect order of exception handlers causes a syntax error.

- âŒ **1**
  - The output will not be '1' because the code will not execute correctly.

- âŒ **a**
  - The incorrect order of exception handlers prevents 'a' from being printed.

- âœ… **The code will cause a syntax error.**
  - The generic `except:` block must be placed last in a series of exception handlers.

### Explanation:
In Python, `except:` must be the last handler; placing it before other handlers results in a syntax error.

---

## What is the expected output of the following code?

```python
data = {'z': 23, 'x': 7, 'y': 42}
 
for _ in sorted(data):
    print(data[_], end=' ')
```

**Domain:** Data Aggregates

### Options:
- âŒ **42 23 7**
  - The keys are sorted lexicographically ('x', 'y', 'z'), not numerically.

- âœ… **7 42 23**
  - Sorting `data` keys lexicographically results in the order `x`, `y`, `z`, whose values are `7, 42, 23`.

- âŒ **7 23 42**
  - Sorting applies to dictionary keys, not values. The values are accessed in the sorted key order.

### Explanation:
Dictionaries do not maintain order, so sorting the keys results in them being accessed in lexicographical order.

---

## Insert the correct snippet to convert the `t` tuple to a dictionary named `d`.

Expected output:
```python
{'A': 1, 'B': 2, 'C': 3}
```

Code:
```python
t = (('A', 1), ('B', 2), ('C', 3))
# insert code here
print(d)
```

**Domain:** Data Aggregates

### Options:
- âœ… **d = dict(t)**
  - The `dict()` constructor converts a tuple of key-value pairs into a dictionary.

- âŒ **d.dict(t)**
  - `dict()` should be called directly, not as a method of `d`.

- âŒ **d = t(dict)**
  - This syntax is invalid.

- âŒ **t >> d.dict**
  - This is not a valid way to create a dictionary in Python.

### Explanation:
Python's built-in `dict()` function allows for direct conversion of a tuple of key-value pairs into a dictionary.

---

## What is machine code?

**Domain:** Basics

### Options:
- âŒ **A high-level programming language consisting of instruction lists that humans can read and understand**
  - Machine code is a low-level language and is not meant for human readability.

- âœ… **A low-level programming language consisting of binary digits/bit that the computer reads and understands**
  - Machine code consists of binary instructions that are directly executed by the CPU.

- âŒ **A low-level programming language consisting of hexadecimal digits that make up high-level language instructions**
  - Hexadecimal notation is sometimes used to represent machine code, but the code itself is in binary.

- âŒ **A medium-level programming language consisting of the assembly code designed for the computer processor**
  - Assembly code is a human-readable abstraction of machine code.

### Explanation:
Machine code consists of raw binary instructions that the processor executes directly.

---

## What will be the output of the following code?

```python
x = [0, 1, 2]
x[0], x[2] = x[2], x[0]
print(x)
```

**Domain:** Operators

### Options:
- âŒ **It shortens the list.**
  - The assignment swaps two values but does not remove elements.

- âŒ **It extends the list.**
  - No new elements are added; only values are swapped.

- âŒ **It doesnâ€™t change the list.**
  - The values at index `0` and `2` are swapped, so the list is modified.

- âœ… **It reverses the list.**
  - The swap operation effectively reverses the list from `[0, 1, 2]` to `[2, 1, 0]`.

### Explanation:
Python allows tuple-style assignment for swapping elements, which modifies the list structure.

---

## What is the expected output of the following code?

```python
def fun(x):
    x += 1
    return x
 
x = 2
x = fun(x + 1)
print(x)
```

**Domain:** Functions

### Options:
- âŒ **5**
  - The function increments the argument `x + 1` (which is `3`), resulting in `4`, not `5`.

- âŒ **The code is erroneous.**
  - The code executes correctly without errors.

- âœ… **4**
  - The function is called with `3`, which is incremented by `1`, resulting in `4`.

- âŒ **3**
  - The function adds `1` to `x`, returning `4`.

### Explanation:
The function correctly takes an integer, increments it, and returns the modified value.

---

## Which of the following snippets correctly converts the tuple `t` to a dictionary named `d`?

```python
t = (('A', 1), ('B', 2), ('C', 3))
# insert code here
print(d)
```

**Domain:** Data Aggregates

### Options:
- âœ… **d = dict(t)**
  - Using `dict()` with a tuple of key-value pairs properly converts it into a dictionary.

- âŒ **d.dict(t)**
  - This syntax is invalid; `dict()` is not a method of `d`.

- âŒ **d = t(dict)**
  - This syntax is incorrect and does not create a dictionary.

- âŒ **t >> d.dict**
  - This is an invalid way to create a dictionary from a tuple.

### Explanation:
The `dict()` constructor properly transforms a tuple of pairs into a dictionary.

---

## What is the expected output of the following code?

```python
data = {'z': 23, 'x': 7, 'y': 42}
for _ in sorted(data):
    print(data[_], end=' ')
```

**Domain:** Data Aggregates

### Options:
- âŒ **42 23 7**
  - Sorting applies to dictionary keys (`'x'`, `'y'`, `'z'`), not their values.

- âœ… **7 42 23**
  - The dictionary keys are sorted alphabetically, leading to values being printed in order of `x`, `y`, and `z`.

- âŒ **7 23 42**
  - The sorting occurs based on keys, not values.

### Explanation:
The `sorted()` function sorts the dictionary keys alphabetically before accessing their values.

---

## Which of the following statements about keywords in Python are true?

(Select two answers)

**Domain:** Basics

### Options:
- âœ… **You cannot use keywords as variable names in Python.**
  - Python reserves keywords for specific purposes, so they cannot be used as variable names.

- âŒ **You can use keywords as variable names in Python.**
  - Keywords are restricted and cannot be used as variable names.

- âŒ **You can use keywords as function names in Python.**
  - Using keywords as function names will cause a syntax error.

- âœ… **You cannot use keywords as function names in Python.**
  - Keywords are reserved and cannot be redefined as function names.

### Explanation:
Python keywords are predefined and cannot be used for variable or function names.

---

## What is the expected output of the following code?

```python
room = input('Enter the room number: ')
rooms = {101: 'Gathering Place', 102: 'Meeting Room'}
if not room in rooms:
    print('The room doesn\'t exist.')
else:
    print('The room name is: ' + rooms[room])
```

**Domain:** Control Flow

### Options:
- âŒ **Misnamed variable(s)**
  - The variables `room` and `rooms` are correctly named; the error is due to a type mismatch.

- âœ… **Mismatched data type(s)**
  - `input()` returns a string, but the dictionary keys are integers, causing the lookup to fail.

- âŒ **None of the above.**
  - The issue is due to type mismatching, which prevents the dictionary lookup from succeeding.

- âŒ **Invalid Syntax**
  - The syntax is correct, but the data types do not match.

### Explanation:
Dictionary keys are integers, but `input()` returns a string, leading to a failed lookup.

---

## What is the result of the following code?

```python
x = 7
y = x % 2
y += 1
print(y)
```

**Domain:** Operators

### Options:
- âœ… **2**
  - The modulus operation `7 % 2` results in `1`, and adding `1` gives `2`.

- âŒ **1**
  - The value of `y` is incremented, so the final result is `2`.

- âŒ **3**
  - The correct result is `2`, not `3`.

- âŒ **5**
  - The final result is `2`, not `5`.

### Explanation:
The modulus operator returns the remainder of division, and `+=` increments the result.

---

## Which of the following is the correct way to handle multiple exceptions in a single `except` clause?

**Domain:** Error Handling

### Options:
- âœ… **except (TypeError, ValueError, ZeroDivisionError):
    # Some code.**
  - Grouping exceptions inside parentheses correctly specifies multiple exception types.

- âŒ **except: (TypeError, ValueError, ZeroDivisionError)
    # Some code.**
  - Incorrect syntax; exceptions should be listed inside parentheses following `except`.

- âŒ **except TypeError, ValueError, ZeroDivisionError:
    # Some code.**
  - This syntax is incorrect; multiple exceptions must be enclosed in parentheses.

- âŒ **except: TypeError, ValueError, ZeroDivisionError
    # Some code.**
  - This is not valid Python syntax for handling multiple exceptions.

### Explanation:
When handling multiple exceptions in a single `except` clause, they must be grouped inside parentheses.

---

## What is the default value of encoding in the string function `encode()`?

**Domain:** Basics

### Options:
- âŒ **utf-16**
  - The default encoding is not `utf-16`. While `utf-16` is a valid encoding format, Python uses `utf-8` by default.

- âœ… **utf-8**
  - The default encoding for the `encode()` method in Python is `utf-8`, which is widely used for text encoding.

- âŒ **ascii**
  - ASCII is a valid encoding, but it is not the default encoding in Python.

- âŒ **qwerty**
  - `qwerty` is not a valid encoding format.

### Explanation:
The `encode()` function defaults to `utf-8` encoding in Python. This ensures compatibility with most text-based applications.

---

## What is machine code?

**Domain:** Basics

### Options:
- âŒ **A high-level programming language consisting of instruction lists that humans can read and understand.**
  - Machine code is not high-level; it consists of binary instructions executed by the CPU.

- âœ… **A low-level programming language consisting of binary digits/bit that the computer reads and understands.**
  - Machine code is made up of binary instructions that the CPU executes directly.

- âŒ **A low-level programming language consisting of hexadecimal digits that make up high-level language instructions.**
  - Machine code is binary, not hexadecimal, although hexadecimal is often used as a human-readable representation.

- âŒ **A medium-level programming language consisting of the assembly code designed for the computer processor.**
  - Assembly language is a low-level language that is more readable than machine code but is not machine code itself.

### Explanation:
Machine code is a binary-based set of instructions executed directly by the CPU.

---

## Which of the following statements about the `not` operator in Python are correct?

**Domain:** Data Types

### Options:
- âŒ **`not 0` evaluates to `False`.**
  - The `not` operator inverts the truth value, so `not 0` evaluates to `True` since `0` is considered `False`.

- âœ… **`not 23` evaluates to `False`.**
  - Since any non-zero number is considered `True`, `not 23` evaluates to `False`.

- âŒ **`not ''` evaluates to `False`.**
  - An empty string (`''`) is considered `False`, so `not ''` evaluates to `True`.

- âœ… **`not None` evaluates to `True`.**
  - `None` is considered `False`, so `not None` evaluates to `True`.

### Explanation:
The `not` operator negates the truth value of an expression, converting `False` to `True` and vice versa.

---

## What is the expected output of the following code?

```python
def get_names():
    names = ['Peter', 'Paul', 'Mary', 'Jane', 'Steve']
    return names[2:]


def update_names(names):
    res = []
    for name in names:
        res.append(name[:3].upper())
    return res

print(update_names(get_names()))
```

**Domain:** Functions

### Options:
- âŒ **['JA', 'ST']**
  - The slicing starts at index `2`, which includes `Mary`, `Jane`, and `Steve`, so two elements are missing.

- âŒ **['JAN', 'STE']**
  - This choice includes only the last two names, but the slicing starts at `Mary`, so `MAR` should also be included.

- âœ… **['MAR', 'JAN', 'STE']**
  - The function slices the list from `Mary` onward, then extracts the first three letters from each name and converts them to uppercase.

- âŒ **['MA', 'JA', 'ST']**
  - Each name slice takes the first three letters, not two.

### Explanation:
The function `get_names()` slices the list from `Mary` onwards, and `update_names()` converts the first three letters of each name to uppercase.

---

## What is the expected output of the following code?

```python
x = [1, 2, 3, 4, 5, 6, 7, 8, 9]
x[::2] = 10, 20, 30, 40, 50, 60
print(x)
```

**Domain:** Data Aggregates

### Options:
- âŒ **[10, 2, 20, 4, 30, 6, 40, 8, 50, 60]**
  - The code is erroneous because the number of replacement values does not match the number of elements selected by slicing.

- âŒ **[1, 2, 10, 20, 30, 40, 50, 60]**
  - This does not match the behavior of the slicing operation.

- âŒ **[1, 10, 3, 20, 5, 30, 7, 40, 9, 50, 60]**
  - The list update does not work because of mismatched lengths.

- âœ… **The code is erroneous.**
  - The number of elements assigned does not match the number of selected indices, causing an error.

### Explanation:
List slicing assigns values to selected indices, but the number of elements must match the number of selected positions.

---

## Which of the following expressions correctly follows the given arithmetic formula?

The formula: `b = (-a) ** 2`, where `a` is input and `b` is the computed result.

**Domain:** Operators

### Options:
- âŒ **b = -(a) ** 2**
  - The negative sign is applied after exponentiation, which does not match the formula.

- âœ… **b = (-a) ** 2**
  - This correctly applies negation to `a` before squaring.

- âŒ **b = (a-) ** 2**
  - Invalid syntax; `-` cannot be placed after `a` in this way.

- âŒ **b = (a) ** -2**
  - Raising to `-2` takes the reciprocal squared, which does not match the formula.

### Explanation:
Operator precedence is key here: negation must be applied before exponentiation.

---

## Which of the following is the correct way to handle multiple exceptions in a single `except` clause?

**Domain:** Error Handling

### Options:
- âœ… **`except (TypeError, ValueError, ZeroDivisionError):`**
  - Grouping exceptions inside parentheses allows multiple exceptions to be caught.

- âŒ **`except: (TypeError, ValueError, ZeroDivisionError)`**
  - Incorrect syntax; exceptions must be inside parentheses following `except`.

- âŒ **`except TypeError, ValueError, ZeroDivisionError:`**
  - Multiple exceptions must be enclosed in parentheses.

- âŒ **`except: TypeError, ValueError, ZeroDivisionError`**
  - Incorrect syntax; the list of exceptions must be inside parentheses.

### Explanation:
Python requires multiple exceptions to be grouped within parentheses in a single `except` clause.

---

## What will be the output of the following code?

```python
def func(a, b):
    return a ** a

print(func(2))
```

**Domain:** Functions

### Options:
- âŒ **It will output 4**
  - The function expects two arguments, but only one is provided, leading to an error.

- âŒ **It will return None**
  - The function is defined with two parameters but called with only one argument, causing an error.

- âœ… **It is erroneous**
  - The function call is missing the second required argument, which results in a `TypeError`.

- âŒ **It will output 2**
  - The function would calculate `2**2` if properly called, but the missing argument makes it invalid.

### Explanation:
Python functions must be called with the correct number of arguments unless default values are provided.

---

## Consider the following code snippet:

```python
room = input('Enter the room number: ')
rooms = {101: 'Gathering Place', 102: 'Meeting Room'}
if not room in rooms:
    print('The room doesn\'t exist.')
else:
    print('The room name is: ' + rooms[room])
```

**Domain:** Control Flow

### Options:
- âŒ **Misnamed variable(s)**
  - All variables are correctly named. The issue is related to data types.

- âœ… **Mismatched data type(s)**
  - The `input()` function returns a string, while the dictionary keys are integers. This causes a key lookup failure.

- âŒ **None of the above**
  - The issue is a type mismatch between the input and the dictionary keys.

- âŒ **Invalid Syntax**
  - The syntax is valid, but a data type mismatch prevents the dictionary lookup from succeeding.

### Explanation:
The `input()` function always returns a string, which must be converted to an integer before being used as a dictionary key.

---

## Which of the following snippets correctly handle multiple exceptions in a single `except` clause?

**Domain:** Error Handling

### Options:
- âœ… **`except (TypeError, ValueError, ZeroDivisionError):`**
  - Grouping multiple exception types in parentheses allows them to be handled together.

- âŒ **`except: (TypeError, ValueError, ZeroDivisionError)`**
  - This syntax is incorrect; exceptions must be placed inside parentheses after `except`.

- âŒ **`except TypeError, ValueError, ZeroDivisionError:`**
  - Multiple exceptions must be enclosed in parentheses, otherwise it results in a syntax error.

- âŒ **`except: TypeError, ValueError, ZeroDivisionError`**
  - Incorrect syntax; the list of exceptions must be inside parentheses.

### Explanation:
In Python, multiple exceptions should be enclosed in parentheses within a single `except` clause.

---

## What is the expected output of the following code?

```python
t = (('A', 1), ('B', 2), ('C', 3))
d = dict(t)
print(d)
```

**Domain:** Data Aggregates

### Options:
- âœ… **`{'A': 1, 'B': 2, 'C': 3}`**
  - The `dict()` function correctly converts a tuple of key-value pairs into a dictionary.

- âŒ **`d.dict(t)`**
  - This is incorrect syntax; `dict()` should be used as a constructor.

- âŒ **`d = t(dict)`**
  - This is an invalid way to convert a tuple into a dictionary.

- âŒ **`t >> d.dict`**
  - This is incorrect syntax; the `dict()` function must be used explicitly.

### Explanation:
The `dict()` function takes an iterable of key-value pairs and converts it into a dictionary.

---

## Which of the following statements about Python keywords is correct?

**Domain:** Basics

### Options:
- âœ… **You cannot use keywords as variable names in Python**
  - Python keywords have predefined meanings and cannot be used as variable names.

- âŒ **You can use keywords as variable names in Python**
  - Python does not allow using keywords as variable names.

- âŒ **You can use keywords as function names in Python**
  - Python keywords cannot be used as function names.

- âœ… **You cannot use keywords as function names in Python**
  - Python reserves keywords for specific functionalities, preventing their use as function names.

### Explanation:
Keywords in Python have predefined meanings and cannot be used as variable or function names.

---

## What is the output of the following code?

```python
def fun(x):
    x += 1
    return x

x = 2
x = fun(x + 1)
print(x)
```

**Domain:** Functions

### Options:
- âŒ **5**
  - The function increments the input value by 1, resulting in `4`, not `5`.

- âŒ **The code is erroneous**
  - The code runs correctly and produces an output.

- âœ… **4**
  - The function receives `3` as input (`x + 1`), increments it by `1`, and returns `4`.

- âŒ **3**
  - The function adds `1` to the input value, making the result `4`, not `3`.

### Explanation:
The function receives `3` as input, increments it, and returns `4`.

---

## What is the correct way to convert a tuple to a dictionary?

**Domain:** Data Aggregates

### Options:
- âœ… **`d = dict(t)`**
  - Using `dict()` with a tuple of key-value pairs correctly creates a dictionary.

- âŒ **`d.dict(t)`**
  - This is incorrect syntax.

- âŒ **`d = t(dict)`**
  - This is not a valid way to convert a tuple to a dictionary.

- âŒ **`t >> d.dict`**
  - This is incorrect syntax.

### Explanation:
The `dict()` function is used to create a dictionary from an iterable of key-value pairs.

---

## What is machine code?

**Domain:** Basics

### Options:
- âŒ **A high-level programming language consisting of instruction lists that humans can read and understand.**
  - Machine code is not high-level and is not meant to be human-readable.

- âœ… **A low-level programming language consisting of binary digits/bit that the computer reads and understands.**
  - Machine code consists of binary instructions that the CPU executes directly.

- âŒ **A low-level programming language consisting of hexadecimal digits that make up high-level language instructions.**
  - Machine code is primarily binary, though hexadecimal is used for human readability.

- âŒ **A medium-level programming language consisting of assembly code designed for the computer processor.**
  - Assembly is a low-level representation of machine code but is not machine code itself.

### Explanation:
Machine code is the lowest-level representation of a program, consisting of binary instructions executed directly by the CPU.

---

## What is the expected output of the following code?

```python
data = {}
data[1] = 1
data['1'] = 2
data[1.0] = 4
 
res = 0
for d in data:
    res += data[d]
 
print(res)
```

**Domain:** Data Aggregates

### Options:
- âœ… **6**
  - The expected output is 6 because the dictionary treats 1 and 1.0 as the same key, overwriting the previous value.

- âŒ **3**
  - The output is not 3; the dictionary keys are 1, '1', and 1.0, with values of 4, 2, and 4 respectively.

- âŒ **The code is erroneous.**
  - The code is valid and executes correctly.

- âŒ **7**
  - The sum is not 7, as the keys are iterated and their values summed up, resulting in 6.

### Explanation:
Dictionary keys 1 and 1.0 are considered the same, leading to overwriting of values.

---

## Which of the following operators can be used with strings?

**Domain:** Data Types

### Options:
- âŒ **1) +
2) *
3) -
4) in**
  - The '-' operator is not valid for strings in Python.

- âŒ **1, 2**
  - While + and * are valid, 'in' is also applicable for substring checking.

- âœ… **1, 2, 4**
  - The + operator concatenates strings, * repeats them, and 'in' checks for substring existence.

- âŒ **1, 2, 3**
  - The '-' operator is not valid for strings in Python.

### Explanation:
Valid string operations include concatenation (+), repetition (*), and substring checking (in).

---

## What is the output of the following snippet?

```python
l1 = [1, 2, 3]
 
for v in range(len(l1)):
    l1.insert(1, l1[v])
 
print(l1)
```

**Domain:** Data Aggregates

### Options:
- âŒ **[1, 2, 3, 1, 2, 3]**
  - The insert operation always shifts elements, altering the list structure.

- âœ… **[1, 1, 1, 1, 2, 3]**
  - The insert function shifts elements, repeatedly inserting at index 1.

- âŒ **[3, 2, 1, 1, 2, 3]**
  - The insert operation does not reverse the list.

- âŒ **[1, 2, 3, 3, 2, 1]**
  - Insertion shifts elements but does not result in this pattern.

### Explanation:
The loop inserts each element at index 1, causing repeated insertions and shifts.

---

## What is the expected output of the following code?

```python
box = {}
jars = {}
crates = {}
 
box['biscuit'] = 1
box['cake'] = 3
 
jars['jam'] = 4
 
crates['box'] = box
crates['jars'] = jars
 
print(len(crates[box]))
```

**Domain:** Data Aggregates

### Options:
- âœ… **The code is erroneous.**
  - Dictionaries cannot use other dictionaries as keys.

- âŒ **3**
  - The error occurs before any valid length computation.

- âŒ **4**
  - The length cannot be computed due to a key error.

- âŒ **2**
  - The dictionary key issue prevents length calculation.

### Explanation:
Dictionaries cannot have other dictionaries as keys due to immutability constraints.

---

## What is the expected output of the following code?

```python
print(chr(ord('p') + 3))
```

**Domain:** Data Types

### Options:
- âŒ **r**
  - Adding 3 to the ASCII value of 'p' results in 's', not 'r'.

- âœ… **s**
  - The `ord()` function retrieves ASCII value, `chr()` converts it back. 'p' + 3 results in 's'.

- âŒ **t**
  - The ASCII value of 'p' plus 3 is 's', not 't'.

- âŒ **q**
  - The ASCII conversion results in 's', not 'q'.

### Explanation:
`ord()` converts a character to its integer ASCII representation, and `chr()` converts it back.

---

## Which of the following enclose the input parameters or arguments of a function?

**Domain:** Functions

### Options:
- âŒ **Quotation marks**
  - Quotation marks are used for strings, not function parameters.

- âœ… **Parentheses**
  - Function parameters are enclosed in parentheses.

- âŒ **Brackets**
  - Brackets are used for indexing, not function parameters.

- âŒ **Curly braces**
  - Curly braces are used for sets and dictionaries, not function parameters.

### Explanation:
Function parameters are always enclosed in parentheses when defining and calling functions.

---

## What will be the output of the following code?

```python
def fun(x):
    x += 1
    return x


x = 2
x = fun(x + 1)
print(x)
```

**Domain:** Functions

### Options:
- âŒ **5**
  - The function increments the value by 1, resulting in 4, not 5.

- âœ… **4**
  - The function receives `3`, increments it, and returns `4`.

- âŒ **3**
  - The function adds `1`, returning `4`, not `3`.

- âŒ **The code is erroneous.**
  - The code executes correctly without errors.

### Explanation:
Function parameters are passed by value, and the returned result is stored in `x`.

---

## What is the expected output of the following code?

```python
for i in range(1, 4):
    if i % 2 == 0:
        print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **No output**
  - The loop iterates over the numbers 1, 2, and 3. Since only 2 is even, the print statement executes once, outputting '*'.

- âœ… *****
  - The condition `i % 2 == 0` is true only for `i = 2`, so one asterisk is printed.

- âŒ ******
  - Only one iteration (when `i = 2`) meets the condition, so only one '*' is printed, not two.

- âŒ *******
  - The loop iterates three times, but only one meets the condition (`i = 2`), so the output is not three asterisks.

### Explanation:
The loop runs three times with values 1, 2, and 3. The condition `i % 2 == 0` is only met when `i = 2`, resulting in a single '*'. 


---

## What will be the value of `x` after executing the following code?

```python
x = 5
x += 2 * 3
```


**Domain:** Operators

### Options:
- âœ… **11**
  - The `+=` operator adds the result of `2 * 3` (which is 6) to `x`, making `x = 5 + 6 = 11`.

- âŒ **10**
  - This would be correct if the multiplication was ignored, but `x += 2 * 3` evaluates as `x = 5 + 6`.

- âŒ **8**
  - This would be correct if the multiplication was `2 + 3` instead of `2 * 3`, but the multiplication takes precedence.

- âŒ **5**
  - The value of `x` is modified by the `+=` operator, so it does not remain 5.

### Explanation:
The multiplication `2 * 3` is evaluated first due to operator precedence, resulting in `6`. Then, `x += 6` adds 6 to the original value of `x`, making it 11.

---

## What will be printed by the following code?

```python
data = [1, 2, 3]
data.append(4)
print(data)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 2, 3]**
  - The `append()` method adds an element to the list, so `4` is added to `data`.

- âœ… **[1, 2, 3, 4]**
  - The `append()` method adds `4` to the list, modifying it to `[1, 2, 3, 4]`.

- âŒ **[4, 1, 2, 3]**
  - The `append()` method adds the new element to the end, not the beginning.

- âŒ **[1, 2, 3], 4**
  - The print statement prints the entire list as a single entity, not as separate values.

### Explanation:
The `append()` method modifies the list by adding an element at the end. In this case, `4` is appended to `[1, 2, 3]`, resulting in `[1, 2, 3, 4]`.

---

## What is the expected output of the following code?

```python
def func(a, b):
    return a + b

print(func(2, 3))
```


**Domain:** Functions

### Options:
- âœ… **5**
  - The function `func` returns the sum of `a` and `b`, which is `2 + 3 = 5`.

- âŒ **23**
  - This would happen if `a` and `b` were strings (`'2' + '3'`), but they are integers.

- âŒ **None**
  - The function contains a return statement, so it does not return `None`.

- âŒ **Error**
  - There are no syntax errors in the function definition or call.

### Explanation:
The function `func` takes two arguments and returns their sum. The call `func(2, 3)` correctly computes `2 + 3`, which results in `5`.

---

## Which of the following variable names are illegal? (Select two answers)


**Domain:** Basics

### Options:
- âœ… **True**
  - The variable name "True" is illegal because it is a reserved keyword in Python and cannot be used as an identifier for a variable.

- âŒ **True**
  - The variable name "TRUE" is a valid variable name in Python as it is case-sensitive and different from the reserved keyword "True".

- âœ… **and**
  - The variable name "and" is illegal because it is a reserved keyword in Python and cannot be used as an identifier for a variable.

- âŒ **True**
  - The variable name "true" is a valid variable name in Python as it is case-sensitive and different from the reserved keyword "True".

### Explanation:
Reserved keywords like "True" and "and" cannot be used as variable names in Python. Python is case-sensitive, so variations like "TRUE" and "true" are allowed.

---

## An operator able to check whether two values are not equal is coded as:


**Domain:** Operators

### Options:
- âŒ **=/=**
  - The `=/=` operator is not a valid operator in Python for checking non-equality between two values. In Python, the `!=` operator is used for this purpose, so `=/=` is an incorrect choice.

- âœ… **!=**
  - The `!=` operator in Python is used to check whether two values are not equal to each other. It is the standard way to express inequality in Python and is the correct choice for checking non-equality between two values.

- âŒ **not ==**
  - The `not ==` operator does not directly check for non-equality. Instead, it negates the equality check. The correct operator for non-equality is `!=`.

- âŒ **<>**
  - The `<>` operator was used in older versions of Python to check for inequality, but it is no longer supported in Python 3. Therefore, it is not valid.

### Explanation:
In Python, the `!=` operator is used to check inequality. Older operators like `<>` or unconventional combinations like `not ==` are either invalid or unnecessary.

---

## Which of the following expressions is equivalent to the expression in the function?

```python
def main(a, b, c, d):
    value = a + b * c - d
    return value
```


**Domain:** Operators

### Options:
- âœ… **(a + (b * c)) - d**
  - This expression is equivalent to the original expression in the function because it first calculates the result of the multiplication operation `(b * c)`, then adds the value of `a`, and finally subtracts the value of `d`.

- âŒ **a + ((b * c) - d)**
  - This expression is not equivalent because it calculates `(b * c) - d` first and then adds `a`, which changes the order of operations.

- âŒ **(a + b) * (c - d)**
  - This expression is incorrect because it adds `a` and `b` first, then multiplies the result by `(c - d)`, which changes the order of operations.

- âŒ **None of the above.**
  - The correct equivalent expression is `(a + (b * c)) - d`, so this choice is incorrect.

### Explanation:
Python follows operator precedence rules. Multiplication (`*`) has higher precedence than addition (`+`) or subtraction (`-`). Parentheses can alter the order of evaluation when used.

---

## `isalnum()` checks if a string contains only letters and digits, and this is:


**Domain:** Functions

### Options:
- âŒ **A function**
  - While `isalnum()` performs a function, it is not a standalone function. It is a method called on a string object.

- âŒ **A module**
  - The `isalnum()` method is not a module. Modules are files containing Python code that can be imported into other programs.

- âœ… **A method**
  - The `isalnum()` method is a built-in method in Python. It checks if a string contains only alphanumeric characters and is associated with string objects.

### Explanation:
In Python, methods like `isalnum()` are tied to specific objects (strings in this case) and are called using dot notation. Modules and functions are distinct entities.

---

## What is the expected output of the following code?

```python
x = 1
y = 2
x, y, z = x, x, y
z, y, z = x, y, z
print(x, y, z)
```


**Domain:** Basics

### Options:
- âŒ **1 2 2**
  - The code reassigns values in a way that results in `x = 1`, `y = 1`, and `z = 2`. Therefore, the output is not `1 2 2`.

- âŒ **2 1 2**
  - The final values of the variables are `x = 1`, `y = 1`, and `z = 2`, so the output is not `2 1 2`.

- âœ… **1 1 2**
  - The code reassigns the values of the variables step by step. The final values are `x = 1`, `y = 1`, and `z = 2`, which results in the output `1 1 2`.

- âŒ **1 2 1**
  - The variables do not hold these values at the end of the code execution. The correct values are `x = 1`, `y = 1`, and `z = 2`.

### Explanation:
Python allows multiple assignments in a single line. The final values of variables depend on the order of assignments, which are evaluated sequentially.

---

## The digraph written as `#!` is used to:


**Domain:** Basics

### Options:
- âŒ **create a docstring.**
  - The digraph `#!` is not used to create a docstring. Docstrings are created using triple quotes (`'''` or `"""`).

- âŒ **tell an MS Windows OS how to execute the contents of a Python file.**
  - The digraph `#!` is used for Unix or Unix-like operating systems, not for Windows. Windows uses file associations or the Python Launcher.

- âŒ **make a particular module entity a private one.**
  - The `#!` digraph does not relate to privacy in Python modules. Underscores (`_`) are used for this purpose.

- âœ… **tell a Unix or Unix-like OS how to execute the contents of a Python file.**
  - The digraph `#!` is known as a shebang and is used in Unix-like systems to specify the interpreter that should run the script.

### Explanation:
The `#!` shebang specifies the path to the interpreter in Unix-based systems, allowing the script to execute directly from the command line.

---

## Which of the following variable names are illegal? (Select two answers)


**Domain:** Basics

### Options:
- âœ… **True**
  - The variable name "True" is illegal because it is a reserved keyword in Python and cannot be used as an identifier for a variable.

- âŒ **True**
  - The variable name "TRUE" is a valid variable name in Python as it is case-sensitive and different from the reserved keyword "True".

- âœ… **and**
  - The variable name "and" is illegal because it is a reserved keyword in Python and cannot be used as an identifier for a variable.

- âŒ **True**
  - The variable name "true" is a valid variable name in Python as it is case-sensitive and different from the reserved keyword "True".

### Explanation:
Reserved keywords like "True" and "and" cannot be used as variable names in Python. Python is case-sensitive, so variations like "TRUE" and "true" are allowed.

---

## An operator able to check whether two values are not equal is coded as:


**Domain:** Operators

### Options:
- âŒ **=/=**
  - The `=/=` operator is not a valid operator in Python for checking non-equality between two values. In Python, the `!=` operator is used for this purpose, so `=/=` is an incorrect choice.

- âœ… **!=**
  - The `!=` operator in Python is used to check whether two values are not equal to each other. It is the standard way to express inequality in Python and is the correct choice for checking non-equality between two values.

- âŒ **not ==**
  - The `not ==` operator does not directly check for non-equality. Instead, it negates the equality check. The correct operator for non-equality is `!=`.

- âŒ **<>**
  - The `<>` operator was used in older versions of Python to check for inequality, but it is no longer supported in Python 3. Therefore, it is not valid.

### Explanation:
In Python, the `!=` operator is used to check inequality. Older operators like `<>` or unconventional combinations like `not ==` are either invalid or unnecessary.

---

## Which of the following expressions is equivalent to the expression in the function?

```python
def main(a, b, c, d):
    value = a + b * c - d
    return value
```


**Domain:** Operators

### Options:
- âœ… **(a + (b * c)) - d**
  - This expression is equivalent to the original expression in the function because it first calculates the result of the multiplication operation `(b * c)`, then adds the value of `a`, and finally subtracts the value of `d`.

- âŒ **a + ((b * c) - d)**
  - This expression is not equivalent because it calculates `(b * c) - d` first and then adds `a`, which changes the order of operations.

- âŒ **(a + b) * (c - d)**
  - This expression is incorrect because it adds `a` and `b` first, then multiplies the result by `(c - d)`, which changes the order of operations.

- âŒ **None of the above.**
  - The correct equivalent expression is `(a + (b * c)) - d`, so this choice is incorrect.

### Explanation:
Python follows operator precedence rules. Multiplication (`*`) has higher precedence than addition (`+`) or subtraction (`-`). Parentheses can alter the order of evaluation when used.

---

## `isalnum()` checks if a string contains only letters and digits, and this is:


**Domain:** Functions

### Options:
- âŒ **A function**
  - While `isalnum()` performs a function, it is not a standalone function. It is a method called on a string object.

- âŒ **A module**
  - The `isalnum()` method is not a module. Modules are files containing Python code that can be imported into other programs.

- âœ… **A method**
  - The `isalnum()` method is a built-in method in Python. It checks if a string contains only alphanumeric characters and is associated with string objects.

### Explanation:
In Python, methods like `isalnum()` are tied to specific objects (strings in this case) and are called using dot notation. Modules and functions are distinct entities.

---

## What is the expected output of the following code?

```python
x = 1
y = 2
x, y, z = x, x, y
z, y, z = x, y, z
print(x, y, z)
```


**Domain:** Basics

### Options:
- âŒ **1 2 2**
  - The code reassigns values in a way that results in `x = 1`, `y = 1`, and `z = 2`. Therefore, the output is not `1 2 2`.

- âŒ **2 1 2**
  - The final values of the variables are `x = 1`, `y = 1`, and `z = 2`, so the output is not `2 1 2`.

- âœ… **1 1 2**
  - The code reassigns the values of the variables step by step. The final values are `x = 1`, `y = 1`, and `z = 2`, which results in the output `1 1 2`.

- âŒ **1 2 1**
  - The variables do not hold these values at the end of the code execution. The correct values are `x = 1`, `y = 1`, and `z = 2`.

### Explanation:
Python allows multiple assignments in a single line. The final values of variables depend on the order of assignments, which are evaluated sequentially.

---

## The digraph written as `#!` is used to:


**Domain:** Basics

### Options:
- âŒ **create a docstring.**
  - The digraph `#!` is not used to create a docstring. Docstrings are created using triple quotes (`'''` or `"""`).

- âŒ **tell an MS Windows OS how to execute the contents of a Python file.**
  - The digraph `#!` is used for Unix or Unix-like operating systems, not for Windows. Windows uses file associations or the Python Launcher.

- âŒ **make a particular module entity a private one.**
  - The `#!` digraph does not relate to privacy in Python modules. Underscores (`_`) are used for this purpose.

- âœ… **tell a Unix or Unix-like OS how to execute the contents of a Python file.**
  - The digraph `#!` is known as a shebang and is used in Unix-like systems to specify the interpreter that should run the script.

### Explanation:
The `#!` shebang specifies the path to the interpreter in Unix-based systems, allowing the script to execute directly from the command line.

---

## What do you call a tool that lets you launch your code step-by-step and inspect it at each moment of execution?


**Domain:** Basics

### Options:
- âŒ **An editor**
  - An editor is a software tool used for writing and editing code. While it provides features like syntax highlighting and code completion, it does not allow step-by-step execution or variable inspection like a debugger does.

- âŒ **A console**
  - A console is a command-line interface for running commands and viewing output. It does not provide the functionality of stepping through code execution or inspecting variables.

- âœ… **A debugger**
  - A debugger is a tool that allows you to execute code step-by-step, pause at specific points, inspect variables, and track the program's flow to identify and fix errors.

### Explanation:
Debuggers are essential tools in programming that provide insight into a program's execution process, helping developers identify and resolve issues in their code.

---

## What is the expected output of the following code?

```python
num = 1

def func():
    num = num + 3
    print(num)

func()

print(num)
```


**Domain:** Functions

### Options:
- âŒ **1 1**
  - The code will raise an `UnboundLocalError` because the variable `num` is being modified inside the function without being declared as global. The output will not be `1 1`.

- âŒ **1 4**
  - The code will raise an `UnboundLocalError` due to the same issue. Python treats `num` as a local variable inside the function, and it is referenced before being assigned.

- âŒ **4 1**
  - The code will raise an `UnboundLocalError`, so this output will not occur.

- âŒ **4 4**
  - The code is erroneous, and an `UnboundLocalError` will prevent any output.

- âœ… **The code is erroneous.**
  - The code raises an `UnboundLocalError` because the variable `num` is treated as local inside the function and is referenced before assignment.

### Explanation:
To avoid an `UnboundLocalError`, you can declare `num` as global inside the function or modify the code to avoid conflicting with the global variable. Shadowing occurs when a local variable hides a variable in the outer scope.

---

## Which of the following for loops would output the below number pattern?

```
11111
22222
33333
44444
55555
```


**Domain:** Control Flow

### Options:
- âŒ **```python
for i in range(0, 5):
    print(str(i) * 5)
```
**
  - This loop starts at 0, so the output will include a line of `00000` at the beginning, which does not match the desired pattern.

- âœ… **```python
for i in range(1, 6):
    print(str(i) * 5)
```
**
  - This loop iterates from 1 to 5 (inclusive of 1 and exclusive of 6), and prints each number as a string, repeated 5 times. This produces the correct pattern.

- âŒ **```python
for i in range(1, 6):
    print(i, i, i, i, i)
```
**
  - This loop outputs the numbers with spaces between them, such as `1 1 1 1 1`. The desired pattern requires no spaces between the digits.

- âŒ **```python
for i in range(1, 5):
    print(str(i) * 5)
```
**
  - This loop excludes the number `5` because the range ends at `5` (exclusive). As a result, it does not produce the complete desired pattern.

### Explanation:
To generate the exact pattern, you need to use `range(1, 6)` to include numbers 1 through 5, and multiply the string representation of the number by 5 to create repeated digits without spaces.

---

## What is the output of the following snippet?

```python
dct = {}
dct['1'] = (1, 2)
dct['2'] = (2, 1)

for x in dct.keys():
    print(dct[x][1], end='')
```


**Domain:** Data Aggregates

### Options:
- âŒ **(1,2)**
  - The code accesses and prints specific elements from the tuples, not the tuples themselves. This output is incorrect.

- âŒ **(2,1)**
  - Similarly, this output is incorrect because the code accesses individual elements from the tuples, not the tuples themselves.

- âœ… **21**
  - The code iterates through the dictionary keys and prints the second element (`[1]`) of each tuple in the order of insertion. The result is `21`.

- âŒ **12**
  - The code prints the second element of each tuple in the order they were added to the dictionary, which is `21`, not `12`.

### Explanation:
Dictionary keys are iterated in the order they are inserted (Python 3.7+). Accessing `dct[x][1]` retrieves the second element of each tuple, resulting in the concatenated output `21`.

---

## What is the expected output of the following code?

```python
x = 1

if x > 0 or x < 1:
    print("1")
if x > 1:
    print("2")
elif x >= 1:
    print("3")
else:
    print("4")
```


**Domain:** Control Flow

### Options:
- âŒ **1
3
4
**
  - The first condition prints "1", and the `elif` condition prints "3". The `else` block will not execute as the `elif` condition is true, so "4" is not printed.

- âŒ **1
4
**
  - The first condition prints "1", but the `elif` condition is true and prints "3", so the `else` block is skipped.

- âŒ **1**
  - The first condition prints "1", but the code also evaluates the `elif` condition and prints "3".

- âœ… **1
3
**
  - The first condition prints "1" because `x > 0` is true. The `elif` condition `x >= 1` is also true, so "3" is printed. The `else` block does not execute.

### Explanation:
The `if`, `elif`, and `else` blocks are evaluated sequentially. The `or` condition in the first block evaluates to true, and the `elif` condition also evaluates to true. Only the first matching branch of `elif` or `else` is executed.

---

## The result of the following addition:

```python
123 + 0.0
```


**Domain:** Operators

### Options:
- âŒ **is equal to 123**
  - The addition of an integer and a float always results in a float. The result will be `123.0`, not an integer `123`.

- âœ… **is equal to 123.0**
  - When adding an integer (`123`) and a float (`0.0`), Python automatically promotes the result to a float, resulting in `123.0`.

- âŒ **cannot be evaluated**
  - The addition can be evaluated in Python without any issues. The result will be a float, `123.0`.

### Explanation:
Python promotes integers to floats in arithmetic operations involving both types. Therefore, `123 + 0.0` evaluates to `123.0`.

---

## What is the expected output of the following code?

```python
def func(x):
    return 1 if x % 2 != 0 else 2

print(func(func(1)))
```


**Domain:** Control Flow

### Options:
- âŒ **The code is erroneous.**
  - The code is syntactically correct and will execute without errors. It uses a conditional expression to return values based on whether `x` is odd or even.

- âŒ **2**
  - The inner `func(1)` call returns `1`, which is odd. The outer `func(1)` also evaluates to `1`. Therefore, the output is not `2`.

- âœ… **1**
  - The inner `func(1)` call returns `1` because `1 % 2 != 0`. The outer call then evaluates `func(1)`, which also returns `1`. Thus, the final output is `1`.

- âŒ **None**
  - The code executes correctly and produces a specific output. It does not return `None`.

### Explanation:
This code uses nested function calls. The inner call returns `1`, which is passed to the outer call, producing the same result. The logic relies on the modulus operator and a conditional expression.

---

## What is CPython?


**Domain:** Basics

### Options:
- âŒ **It is a programming language that is a superset of the C language, designed to produce Python-like performance with code written in C.
**
  - CPython is not a programming language but an implementation of the Python language. It is not designed to produce Python-like performance with C code.

- âŒ **It is a programming language that is a superset of Python, designed to produce C-like performance with code written in Python.
**
  - CPython is not a programming language or a superset of Python. It is the default implementation of Python, written in C.

- âŒ **It is a default, reference implementation of the C language, written in Python.
**
  - CPython is not an implementation of the C language. It is the reference implementation of the Python programming language, written in C.

- âœ… **It is a default, reference implementation of the Python language, written in C.
**
  - CPython is the standard implementation of Python, written in C. It is widely used and serves as the reference implementation for Python.

### Explanation:
CPython is the most widely used implementation of Python, written in C to ensure portability and performance across platforms.

---

## What is the expected output of the following code?

```python
nums = [3, 4, 5, 20, 5, 25, 1, 3]
nums.pop(1)
print(nums)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 3, 4, 5, 20, 5, 25]**
  - This output is incorrect because the `pop()` method removes the element at a specific index. The list is not modified in this manner.

- âŒ **[1, 3, 3, 4, 5, 5, 20, 25]**
  - This output is incorrect. The `pop(1)` method removes the second element in the list, but it does not reorder or duplicate any elements.

- âœ… **[3, 5, 20, 5, 25, 1, 3]**
  - The `pop(1)` method removes the element at index 1 (`4`). The resulting list is `[3, 5, 20, 5, 25, 1, 3]`.

- âŒ **[3, 4, 5, 20, 5, 25, 1, 3]**
  - This output is incorrect because the `pop(1)` method removes the element at index 1. The list remains unchanged in this choice, which is not correct.

### Explanation:
The `pop()` method removes an element at the specified index. In this case, it removes the second element (`4`), resulting in `[3, 5, 20, 5, 25, 1, 3]`.

---

## What will be the output of the following code snippet?

```python
x = 2
y = 1
x *= y + 1
print(x)
```


**Domain:** Operators

### Options:
- âŒ **1**
  - This is incorrect because the code multiplies `x` by `y + 1`, not just `y`. The result is `4`, not `1`.

- âœ… **4**
  - The expression `x *= y + 1` calculates `x = x * (y + 1)`. Since `x = 2` and `y = 1`, the result is `x = 2 * 2 = 4`.

- âŒ **3**
  - The result is not `3` because the code multiplies `x` by `y + 1`, which equals `2`. The result is `4`.

- âŒ **None**
  - The code does produce an output. It calculates the result of `x *= y + 1` and prints `4`.

- âŒ **2**
  - The result is not `2` because the code multiplies `x` by `y + 1`. The calculation `2 * (1 + 1)` results in `4`.

### Explanation:
The `+=`, `*=`, and similar operators follow operator precedence rules. Here, the addition (`y + 1`) is evaluated first, then multiplied by `x`.

---

## The value thirty point eleven times ten raised to the power of nine should be written as:


**Domain:** Data Types

### Options:
- âŒ **30.11E9.0**
  - The format `30.11E9.0` is incorrect because the exponent in scientific notation must be an integer. Decimal points are not allowed in the exponent.

- âœ… **30.11E9**
  - This is the correct representation of thirty point eleven times ten raised to the power of nine. Scientific notation in Python uses the format `<number>E<integer>`.

- âŒ **30E11.9**
  - The format `30E11.9` is invalid because the exponent must be an integer. Decimal exponents are not allowed in Python's scientific notation.

- âŒ **30.11*10^9**
  - This format is not valid scientific notation in Python. The correct format uses the `E` symbol to represent the exponent, as in `30.11E9`.

### Explanation:
Scientific notation in Python uses `E` to represent powers of ten, followed by an integer exponent. For example, `30.11E9` means `30.11 * 10^9`.

---

## What will be the output of the following code snippet?

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[::2])
```


**Domain:** Data Aggregates

### Options:
- âœ… **[1, 3, 5, 7, 9]**
  - The slice `a[::2]` starts at the beginning of the list and selects every second element. The result is `[1, 3, 5, 7, 9]`.

- âŒ **[1, 2, 3]**
  - The slicing with `a[::2]` does not select only the first three elements. It selects every second element from the start, resulting in `[1, 3, 5, 7, 9]`.

- âŒ **[8, 9]**
  - The slicing does not select only the last two elements. It selects every second element from the beginning, resulting in `[1, 3, 5, 7, 9]`.

- âŒ **[1, 2]**
  - The slicing does not select only the first two elements. It selects every second element from the start, resulting in `[1, 3, 5, 7, 9]`.

### Explanation:
List slicing allows you to specify a step value. A step of `2` selects every second element from the list. Here, the slice `[::2]` starts at the beginning and includes `[1, 3, 5, 7, 9]`.

---

## Strings in Python are delimited with:


**Domain:** Data Types

### Options:
- âŒ **dollar symbol (i.e., $)**
  - Strings in Python are not delimited with dollar symbols. They must be enclosed in either single quotes (`'`) or double quotes (`"`).

- âœ… **double quotes (i.e., ") or single quotes (i.e., ')**
  - Strings in Python can be delimited with either single quotes (`'`) or double quotes (`"`). Both are valid and interchangeable.

- âŒ **backslashes (i.e., \)**
  - Backslashes are used to escape special characters within strings, but they do not delimit strings themselves.

- âŒ **asterisks (i.e., *)**
  - Strings in Python are not delimited with asterisks. They must be enclosed in single or double quotes.

### Explanation:
Python strings are enclosed in quotes. Single (`'`) and double (`"`) quotes are interchangeable, allowing flexibility when creating string literals.

---

## What is the expected output of the following code?

```python
list1 = [1, 3]
list2 = list1
list1[0] = 4
print(list2)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 3]**
  - The output is not `[1, 3]` because `list2` references the same object as `list1`. When `list1[0]` is modified, the change is reflected in `list2`.

- âŒ **[1, 3, 4]**
  - The output is not `[1, 3, 4]`. The modification only changes the first element of the list and does not add a new element.

- âœ… **[4, 3]**
  - Both `list1` and `list2` reference the same list object. When `list1[0]` is updated to `4`, the change is visible in `list2`, resulting in `[4, 3]`.

- âŒ **[1, 4]**
  - The output is not `[1, 4]`. The first element of the list is updated to `4`, and the second element remains `3`.

### Explanation:
Lists are mutable and are passed by reference in Python. Changes made to one reference affect all other references to the same list.

---

## What is the output of the following snippet?

```python
dictionary = {'one': 'two', 'three': 'one', 'two': 'three'}
v = dictionary['one']

for k in range(len(dictionary)):
    v = dictionary[v]

print(v)
```


**Domain:** Data Aggregates

### Options:
- âœ… **two**
  - The initial value of `v` is `'two'`. During each iteration of the loop, `v` is updated based on the dictionary. After the loop, `v` points back to `'two'`.

- âŒ **('one', 'two', 'three')**
  - The loop does not produce a tuple of the dictionary values. It updates `v` iteratively, resulting in the final value `'two'`.

- âŒ **three**
  - The loop updates `v` based on the dictionary values, but it does not end with `'three'`. The final value is `'two'`.

- âŒ **one**
  - While `v` temporarily holds `'one'` during the loop, it ultimately points back to `'two'` after all iterations.

### Explanation:
The dictionary lookup cycles through the keys and values, eventually settling on `'two'` as the final result of the loop.

---

## What will be the output of the following code snippet?

```python
x = 1
y = 2
z = x
x = y
y = z
print(x, y)
```


**Domain:** Basics

### Options:
- âœ… **2 1**
  - After the assignments, `x` is updated to the value of `y` (`2`), and `y` is updated to the value of `z` (`1`). The output is `2 1`.

- âŒ **1 2**
  - The values of `x` and `y` are swapped in the code, so the output is not `1 2`.

- âŒ **1 1**
  - The output is not `1 1` because `x` and `y` are updated with new values during the assignments.

- âŒ **2 2**
  - The output is not `2 2` because `y` is updated to the original value of `x` during the assignments.

### Explanation:
Variables in Python are reassigned during the execution of these statements, effectively swapping the values of `x` and `y`.

---

## What is the expected output of the following code?

```python
print(list('hello'))
```


**Domain:** Data Aggregates

### Options:
- âŒ **['h', 'e', 'l', 'l', 'o']**
  - This is incorrect because the characters should be separated by commas within the list. The correct output is `['h', 'e', 'l', 'l', 'o']`.

- âŒ **hello**
  - This is incorrect because the `list()` function converts a string into a list of its characters. The output is not the string `'hello'`.

- âœ… **['h', 'e', 'l', 'l', 'o']**
  - The `list()` function converts the string `'hello'` into a list of individual characters: `['h', 'e', 'l', 'l', 'o']`.

- âŒ **None of the above.**
  - The output is `['h', 'e', 'l', 'l', 'o']`, so this choice is incorrect.

- âŒ **['h', 'e', 'l', 'l', 'o']**
  - This is incorrect because the characters should be enclosed in quotes to represent string literals. Without quotes, they are treated as variables.

### Explanation:
The `list()` function breaks a string into individual characters, producing a list where each character is a separate string element.

---

## What is the expected output of the following code?

```python
z = y = x = 1
print(x, y, z, sep='*')
```


**Domain:** Data Types

### Options:
- âŒ **1 1 1**
  - The `sep='*'` argument specifies the separator between values. The output is `1*1*1`, not `1 1 1`.

- âœ… **1*1*1**
  - The `sep='*'` argument ensures that the variables `x`, `y`, and `z` are printed with `*` as the separator. The output is `1*1*1`.

- âŒ **111***
  - The output is not `111*`. The variables are printed separately with `*` as the separator.

- âŒ **x*y*z**
  - The output is not `x*y*z`. The code prints the values of the variables, not their multiplication or names.

- âŒ **The code is erroneous.**
  - The code is valid and executes correctly. It prints the values of `x`, `y`, and `z` with `*` as the separator.

### Explanation:
The `print()` function uses the `sep` parameter to specify a separator between printed values. Here, the separator is set to `*`.

---

## If a list passed into a function as an argument, deleting any of its elements inside the function using the `del` instruction:


**Domain:** Functions

### Options:
- âŒ **will not affect the argument**
  - Lists are mutable objects in Python. When passed to a function, changes made to the list, such as deleting elements, will affect the original list because it is passed by reference.

- âœ… **will affect the argument**
  - When a list is passed into a function, it is passed by reference. This means that any changes made to the list inside the function, such as deleting elements, will directly affect the original list.

- âŒ **will cause a runtime error**
  - Using `del` to delete elements from a list inside a function does not cause a runtime error. It modifies the original list without any issues.

### Explanation:
Lists in Python are mutable and are passed by reference to functions. As a result, changes to the list inside the function reflect on the original list outside the function.

---

## What is the expected output of the following code?

```python
def fun():
    return True
x = fun(False)
print(x)
```


**Domain:** Functions

### Options:
- âŒ **False**
  - The function `fun()` does not return `False`. It always returns `True`. However, the code will raise an error because `fun()` does not accept any arguments.

- âŒ **0**
  - The function `fun()` does not return an integer value. Additionally, the code will raise an error because `fun()` is called with an argument when it does not accept any.

- âœ… **The program will cause an error**
  - The program will raise a `TypeError` because the function `fun()` is defined without parameters but is called with an argument (`False`).

- âŒ **True**
  - While the function `fun()` does return `True`, the program will not reach this point due to the `TypeError` caused by passing an argument to a parameter-less function.

- âŒ **1**
  - The function does not return `1`. Moreover, the program will raise a `TypeError` due to the incorrect function call.

### Explanation:
The function `fun()` is defined without any parameters. Calling it with an argument (`False`) causes a `TypeError`, as the function does not expect any arguments.

---

## What is the expected output of the following code?

```python
x = 1 / 2 + 3 // 3 + 4 ** 2
print(x)
```


**Domain:** Operators

### Options:
- âŒ **17**
  - The calculation does not result in `17`. The correct calculation involves `1 / 2 = 0.5`, `3 // 3 = 1`, and `4 ** 2 = 16`, which sum to `17.5`.

- âŒ **8.5**
  - The calculation is not `8.5`. The correct calculation results in `17.5` based on operator precedence.

- âŒ **8**
  - The calculation does not result in `8`. The correct result is `17.5`.

- âœ… **17.5**
  - The expression is evaluated as `1 / 2 + 3 // 3 + 4 ** 2`. Using operator precedence, `1 / 2 = 0.5`, `3 // 3 = 1`, and `4 ** 2 = 16`. Adding these values produces `0.5 + 1 + 16 = 17.5`.

### Explanation:
Operator precedence determines the order of evaluation: `**` (exponentiation) has the highest precedence, followed by `/` and `//` (division), and finally `+` (addition). The correct result is `17.5`.

---

## Which of the following lines correctly invoke the function defined below:

```python
def fun(a, b, c=0):
    # Body of the function.
```

(Select two answers)


**Domain:** Functions

### Options:
- âŒ **fun()**
  - This is incorrect because the function `fun()` requires at least two positional arguments (`a` and `b`). Calling it without arguments raises a `TypeError`.

- âœ… **fun(0, 1, 2)**
  - This is correct because it provides all three parameters in positional order (`a=0`, `b=1`, `c=2`), satisfying the function's requirements.

- âŒ **fun(b=1)**
  - This is incorrect because the function requires at least two arguments, and only one (`b=1`) is provided. A `TypeError` will be raised.

- âœ… **fun(b=0, a=0)**
  - This is correct because it uses keyword arguments (`b=0` and `a=0`) to satisfy the required parameters. The default value for `c` is used.

### Explanation:
The function requires two positional arguments (`a` and `b`). The third parameter (`c`) has a default value and is optional. Arguments can be provided in positional or keyword form.

---

## What is the expected output of the following code?

```python
def func(num):
    res = '*'
    for _ in range(num):
        res += res
    return res

for x in func(2):
    print(x, end='')
```


**Domain:** Functions

### Options:
- âŒ ******
  - The code does not produce just two stars. The function repeats the `'*'` character based on the input, resulting in four stars for `func(2)`.

- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. It produces a specific output based on the repeated doubling of `'*'`.

- âŒ *****
  - The output is not a single star. The function produces a string of repeated `'*'` characters, resulting in `'****'`.

- âœ… ********
  - The function doubles the `'*'` character during each iteration of the loop. For `func(2)`, it results in four stars (`'****'`).

### Explanation:
The loop inside the function doubles the string `res` in each iteration. For `num=2`, the string is doubled twice: `'*' -> '**' -> '****'`. The `for` loop prints each character, resulting in `****`.

---

## How many stars will the following snippet print to the monitor?

```python
i = 4
while i > 0:
    i -= 2
    print('*')
    if i == 2:
        break
else:
    print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **2**
  - The snippet will not print two stars. The `break` statement inside the loop prevents further iterations, resulting in only one star being printed.

- âŒ **0**
  - The snippet does print a star before the `break` statement is executed. Therefore, the output is not zero stars.

- âœ… **1**
  - The while loop runs once and prints a single star before encountering the `break` statement. The `else` block does not execute because the loop exits via `break`.

- âŒ **The snippet will enter an infinite loop.**
  - The snippet does not enter an infinite loop. The loop condition is properly decremented, and the `break` statement ensures the loop exits after one iteration.

### Explanation:
The `break` statement interrupts the while loop before it can complete all iterations. Consequently, only one star is printed, and the `else` block is skipped.

---

## What will be the output of the following code snippet?

```python
z = y = x = 1
print(x, y, z, sep='*')
```


**Domain:** Data Types

### Options:
- âŒ **1 1 1**
  - The `sep='*'` argument specifies that the values will be separated by `*`, not spaces. The output is `1*1*1`.

- âœ… **1*1*1**
  - The code assigns the value `1` to `x`, `y`, and `z`. When printed with `sep='*'`, the output is `1*1*1`.

- âŒ **111***
  - The values are printed individually, separated by `*`. The output is not a single concatenated string like `111*`.

- âŒ **x*y*z**
  - The code does not compute or print a multiplication of `x`, `y`, and `z`. It simply prints their values separated by `*`.

### Explanation:
The `sep` parameter in `print()` specifies the separator between values. Here, it is set to `*`, producing the output `1*1*1`.

---

## What is the expected output of the following code?

```python
x = 1 / 2 + 3 // 3 + 4 ** 2
print(x)
```


**Domain:** Operators

### Options:
- âŒ **17**
  - The calculation does not result in `17`. Operator precedence determines the order of operations, resulting in a final value of `17.5`.

- âŒ **8.5**
  - The result of the calculation is not `8.5`. The correct calculation produces `17.5`.

- âŒ **8**
  - The output is not `8`. The calculation involves `1 / 2 = 0.5`, `3 // 3 = 1`, and `4 ** 2 = 16`, summing to `17.5`.

- âœ… **17.5**
  - Operator precedence determines the order of evaluation: `4 ** 2 = 16`, `1 / 2 = 0.5`, and `3 // 3 = 1`. Summing these values produces `17.5`.

### Explanation:
Operator precedence dictates that exponentiation (`**`) is evaluated first, followed by division (`/` and `//`), and finally addition (`+`). The calculation is `1 / 2 + 3 // 3 + 16 = 17.5`.

---

## What is the expected output of the following code?

```python
def func(num):
    res = '*'
    for _ in range(num):
        res += res
    return res

for x in func(2):
    print(x, end='')
```


**Domain:** Functions

### Options:
- âŒ ******
  - The output is not just two stars. The function doubles the `'*'` string during each iteration of the loop, resulting in `'****'`.

- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. It calculates and prints a string of stars based on the input.

- âŒ *****
  - The output is not a single star. The function generates a string of stars by repeatedly doubling the string.

- âœ… ********
  - The function doubles the `'*'` string during each iteration. For `func(2)`, the result is four stars (`'****'`), printed one by one.

### Explanation:
The function doubles the string during each iteration of the loop. For `num=2`, the result is `'****'`. The `for` loop outside the function prints each character in the string.

---

## How many stars will the following snippet print to the monitor?

```python
i = 4
while i > 0:
    i -= 2
    print('*')
    if i == 2:
        break
else:
    print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **2**
  - The `break` statement inside the loop ensures that the loop exits after printing one star, so the output is not two stars.

- âŒ **0**
  - The snippet does print a star before the `break` statement is executed, so the output is not zero stars.

- âœ… **1**
  - The loop runs once and prints a single star before the `break` statement interrupts execution. The `else` block is skipped.

- âŒ **The snippet will enter an infinite loop.**
  - The loop condition is properly decremented, and the `break` statement ensures that the loop terminates after one iteration.

### Explanation:
The `break` statement interrupts the while loop, preventing further iterations. Only one star is printed, and the `else` block is skipped.

---

## What is the expected output of the following code?

```python
def func(x):
    return 1 if x % 2 != 0 else 2

print(func(func(1)))
```


**Domain:** Control Flow

### Options:
- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. It correctly defines and calls the function `func`.

- âŒ **2**
  - The inner call `func(1)` evaluates to `1` (since `1 % 2 != 0` is true). The outer call `func(1)` also evaluates to `1`. Thus, the output is not `2`.

- âœ… **1**
  - The inner `func(1)` evaluates to `1` because `1 % 2 != 0` is true. The outer `func(1)` also evaluates to `1`. Therefore, the output is `1`.

- âŒ **None**
  - The function returns an integer (`1` or `2`), not `None`. The output is `1`.

### Explanation:
The function uses a conditional expression to return `1` for odd inputs and `2` for even inputs. The nested call results in `func(func(1))` resolving to `func(1)`, which returns `1`.

---

## What is CPython?


**Domain:** Basics

### Options:
- âŒ **It's a programming language that is a superset of the C language, designed to produce Python-like performance with code written in C.**
  - CPython is not a programming language. It is the reference implementation of Python, written in C.

- âŒ **It's a programming language that is a superset of Python, designed to produce C-like performance with code written in Python.**
  - CPython is not a superset of Python. It is the standard implementation of Python, written in C for efficient execution of Python code.

- âŒ **It's a default, reference implementation of the C language, written in Python.**
  - CPython is not an implementation of the C language. It is an implementation of the Python language, written in C.

- âœ… **It's a default, reference implementation of the Python language, written in C.**
  - CPython is the default and reference implementation of Python, written in C. It is widely used for its compatibility and performance.

### Explanation:
CPython is the standard implementation of Python. Written in C, it is the most widely used version of Python and serves as the reference implementation.

---

## Take a look at the snippet, and choose the true statements:

```python
nums = [1, 2, 3]
vals = nums
del vals[1:2]
```

(Select two answers)


**Domain:** Data Aggregates

### Options:
- âŒ **nums is longer than vals**
  - `nums` and `vals` reference the same list object. Deleting an element via `vals` also affects `nums`. Thus, they cannot have different lengths.

- âœ… **nums and vals are of the same length**
  - Since `nums` and `vals` reference the same list, any changes made through one are reflected in the other. After deleting an element, both lists have the same length.

- âŒ **vals is longer than nums**
  - `vals` and `nums` refer to the same list object. Deleting an element via `vals` reduces the length of both references equally.

- âœ… **nums and vals refer to the same list**
  - Assigning `vals = nums` makes `vals` a reference to the same list object as `nums`. Any modification affects both.

### Explanation:
Lists in Python are mutable and passed by reference. Assigning one list to another variable creates a reference to the same object, so changes to one affect the other.

---

## What would you insert instead of `???` so that the program checks for even numbers?

```python
if ???:
    print('x is an even number')
```


**Domain:** Operators

### Options:
- âŒ **x % x == 0**
  - The condition `x % x == 0` always evaluates to true for any non-zero value of `x`. It does not check for even numbers.

- âœ… **x % 2 == 0**
  - The expression `x % 2 == 0` checks whether `x` is divisible by 2 with no remainder, which is the correct condition for even numbers.

- âŒ **x % 'even' == True**
  - The expression `x % 'even'` is invalid in Python. The modulo operator `%` cannot be used with a string like `'even'`.

- âŒ **x % 1 == 2**
  - The condition `x % 1 == 2` is not valid for checking even numbers. It incorrectly assumes a remainder of 2 from division by 1.

- âŒ **x % 2 == 1**
  - The condition `x % 2 == 1` checks for odd numbers, not even numbers.

### Explanation:
To check for even numbers, the modulo operator `%` is used with the condition `x % 2 == 0`. This ensures that `x` is evenly divisible by 2.

---

## What will happen when you attempt to run the following code?

```python
print(Hello, World!)
```


**Domain:** Error Handling

### Options:
- âœ… **The code will raise the SyntaxError exception.**
  - The code will raise a `SyntaxError` because the string `Hello, World!` is not enclosed in quotation marks, which are required for string literals.

- âŒ **The code will raise the TypeError exception.**
  - A `TypeError` is not raised in this scenario. The issue is related to the syntax of the string, not its type.

- âŒ **The code will raise the ValueError exception.**
  - A `ValueError` is not raised. The error is caused by missing quotation marks around the string.

- âŒ **The code will print Hello, World! to the console.**
  - The code will not execute successfully. The missing quotation marks around the string result in a `SyntaxError`.

- âŒ **The code will raise the AttributeError exception.**
  - An `AttributeError` is not raised in this case. The error is related to the syntax of the string.

### Explanation:
Strings in Python must be enclosed in quotation marks (either single or double). Omitting them results in a `SyntaxError`.

---

## What is the expected output of the following code?

```python
nums = [3, 4, 5, 20, 5, 25, 1, 3]
nums.pop(1)
print(nums)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 3, 4, 5, 20, 5, 25]**
  - This output is incorrect. The `pop()` method removes the element at the specified index, not based on value. The second element (4) is removed.

- âŒ **[1, 3, 3, 4, 5, 5, 20, 25]**
  - This output is incorrect. The `pop()` method removes the element at the specified index and does not duplicate or reorder elements.

- âŒ **[3, 4, 5, 20, 5, 25, 1, 3]**
  - The original list is modified by the `pop()` method. The output does not match the original list because the second element (4) is removed.

- âŒ **[3, 1, 25, 5, 20, 5, 4]**
  - The output is not rearranged. The `pop()` method only removes the second element, leaving the order of the other elements unchanged.

- âœ… **[3, 5, 20, 5, 25, 1, 3]**
  - The `pop(1)` call removes the second element (4). The resulting list is `[3, 5, 20, 5, 25, 1, 3]`.

### Explanation:
The `pop()` method removes the element at the specified index and returns it. For `pop(1)`, the element at index 1 (4) is removed, leaving the modified list.

---

## What is the expected output of the following code?

```python
x = '\''
print(len(x))
```


**Domain:** Basics

### Options:
- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. The single quote is correctly escaped using the backslash (`\`).

- âœ… **1**
  - The variable `x` contains a single character: an escaped single quote (`\'`). The length of the string is 1.

- âŒ **2**
  - The length of the string is not 2. The backslash is an escape character and does not count as a separate character.

- âŒ **0**
  - The length of the string is not 0. The string contains one character, an escaped single quote.

### Explanation:
The backslash (`\`) is used to escape the single quote, allowing it to be included as a character in the string. The `len()` function returns the number of characters in the string, which is 1.

---

## A function definition starts with the keyword:

```python
def my_function():
    pass
```


**Domain:** Functions

### Options:
- âŒ **fun**
  - `fun` is not a keyword in Python. The correct keyword to define a function is `def`.

- âŒ **function**
  - `function` is not the correct keyword for defining functions in Python. The keyword `def` is used instead.

- âœ… **def**
  - The `def` keyword is used to define functions in Python. It is followed by the function name and its parameters.

### Explanation:
In Python, functions are defined using the `def` keyword. This keyword is followed by the function name, parameters (if any), and a colon (`:`).

---

## The result of the following addition:

```python
123 + 0.0
```


**Domain:** Operators

### Options:
- âŒ **is equal to 123**
  - Adding an integer and a float results in a float. The result is `123.0`, not `123`.

- âœ… **is equal to 123.0**
  - When adding an integer (`123`) and a float (`0.0`), Python promotes the result to a float. The output is `123.0`.

- âŒ **cannot be evaluated**
  - The addition of an integer and a float is valid in Python. The result is a float (`123.0`).

### Explanation:
Python automatically promotes integers to floats in arithmetic operations involving both types. The addition of `123` and `0.0` results in a float: `123.0`.

---

## What is the expected output of the following code?

```python
def func(number):
    # insert your code here

print(func(7))
```


**Domain:** Functions

### Options:
- âŒ **return 'number'**
  - Returning the string `'number'` would not return the value of the `number` parameter. The output would be `'number'`, not `7`.

- âŒ **print('number')**
  - Printing `'number'` would display the string `'number'` on the console, but it would not return the parameter value.

- âŒ **print(number)**
  - Printing `number` would display its value (`7`) but return `None`. The function must return the parameter value.

- âœ… **return number**
  - Returning `number` ensures that the function outputs the value of the parameter (`7`) when called.

### Explanation:
To return the value of the parameter, the `return` keyword must be used. Printing the value is insufficient as it does not provide a return value to the caller.

---

## What will be the output of the following code snippet?

```python
x = 2
y = 1
x *= y + 1
print(x)
```


**Domain:** Operators

### Options:
- âŒ **1**
  - The calculation involves multiplying `x` by `y + 1`, which results in `4`, not `1`.

- âœ… **4**
  - The operation `x *= y + 1` evaluates as `x = x * (y + 1)`. Since `x = 2` and `y + 1 = 2`, the result is `4`.

- âŒ **3**
  - The calculation does not result in `3`. The correct result is `4` after evaluating the multiplication.

- âŒ **None**
  - The code does not return `None`. It calculates the result of the multiplication and prints `4`.

### Explanation:
The `*=` operator combines multiplication and assignment. Operator precedence ensures that `y + 1` is calculated first, resulting in `x = 2 * 2 = 4`.

---

## The value thirty point eleven times ten raised to the power of nine should be written as:


**Domain:** Data Types

### Options:
- âŒ **30.11E9.0**
  - Scientific notation in Python requires the exponent to be an integer. `30.11E9.0` is invalid due to the decimal point in the exponent.

- âœ… **30.11E9**
  - Scientific notation in Python uses the format `<number>E<integer>`. `30.11E9` correctly represents thirty point eleven times ten raised to the power of nine.

- âŒ **30E11.9**
  - The exponent in scientific notation must be an integer. `30E11.9` is not a valid representation.

- âŒ **30.11*10^9**
  - `30.11*10^9` is not valid Python syntax for scientific notation. The correct representation is `30.11E9`.

### Explanation:
Scientific notation in Python uses the `E` symbol to denote the power of ten. For example, `30.11E9` represents `30.11 * 10^9`.

---

## What will be the output of the following code snippet?

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[::2])
```


**Domain:** Data Aggregates

### Options:
- âœ… **[1, 3, 5, 7, 9]**
  - The slicing operation `[::2]` selects every second element from the list, starting with the first element. The result is `[1, 3, 5, 7, 9]`.

- âŒ **[1, 2, 3]**
  - The slicing `[::2]` selects every second element, not the first three elements. The result is `[1, 3, 5, 7, 9]`.

- âŒ **[8, 9]**
  - The slicing `[::2]` selects every second element from the start, not just the last two elements. The result is `[1, 3, 5, 7, 9]`.

- âŒ **[1, 2]**
  - The slicing `[::2]` selects every second element, not just the first two elements. The result is `[1, 3, 5, 7, 9]`.

### Explanation:
The slicing syntax `[start:end:step]` allows for selecting elements at specific intervals. The step value `2` ensures every second element is selected.

---

## Strings in Python are delimited with:


**Domain:** Data Types

### Options:
- âŒ **dollar symbol (i.e., $)**
  - Python does not use the dollar symbol to delimit strings. Strings must be enclosed in single or double quotes.

- âœ… **double quotes (i.e., ") or single quotes (i.e., ')**
  - Strings in Python can be enclosed in either single quotes (`'`) or double quotes (`"`). Both are valid.

- âŒ **backslashes (i.e., \\)**
  - Backslashes are used to escape characters within strings but are not used to delimit strings.

- âŒ **asterisks (i.e., *)**
  - Python does not use asterisks to delimit strings. Strings must be enclosed in single or double quotes.

### Explanation:
Python allows flexibility in string delimiters. Either single quotes (`'`) or double quotes (`"`) can be used to define string literals.

---

## What is the expected output of the following code?

```python
list1 = [1, 3]
list2 = list1
list1[0] = 4
print(list2)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 3]**
  - `list1` and `list2` reference the same list object. Modifying `list1` also affects `list2`, so the output is not `[1, 3]`.

- âŒ **[1, 3, 4]**
  - The code modifies an existing element in the list but does not add new elements. The output is not `[1, 3, 4]`.

- âœ… **[4, 3]**
  - `list1` and `list2` reference the same list. Changing `list1[0]` to `4` updates the shared list, so `list2` outputs `[4, 3]`.

- âŒ **[1, 4]**
  - The first element of the list is changed to `4`. The output is `[4, 3]`, not `[1, 4]`.

### Explanation:
Lists are mutable, and assigning one list to another variable creates a reference to the same object. Changes to the list affect all references.

---

## What is the output of the following snippet?

```python
dictionary = {'one': 'two', 'three': 'one', 'two': 'three'}
v = dictionary['one']

for k in range(len(dictionary)):
    v = dictionary[v]

print(v)
```


**Domain:** Data Aggregates

### Options:
- âœ… **two**
  - The loop iterates over the dictionary, reassigning `v` based on the current value of `dictionary[v]`. After 3 iterations, `v` resolves to `'two'`.

- âŒ **('one', 'two', 'three')**
  - The output is not a tuple. The loop modifies the variable `v` and does not return a collection of the dictionary keys or values.

- âŒ **three**
  - Although `'three'` is a value in the dictionary, the loop resolves `v` to `'two'` after the final iteration.

- âŒ **one**
  - While `'one'` is initially part of the key-value resolution, the loop iterates until `v` resolves to `'two'`.

### Explanation:
The loop iterates through the dictionary values, starting with the value of `'one'`, and resolves `v` through three iterations to the final value `'two'`.

---

## What is the expected output of the following code snippet?

```python
x = 1
y = 2
z = x
x = y
y = z
print(x, y)
```


**Domain:** Basics

### Options:
- âœ… **2 1**
  - The variables are reassigned as follows: `x` takes the value of `y` (`2`), and `y` takes the value of `z` (`1`). The output is `2 1`.

- âŒ **1 2**
  - The values of `x` and `y` are swapped during reassignment. The output is not `1 2`.

- âŒ **1 1**
  - The variable `y` is reassigned to the value of `z`, which holds the initial value of `x`. The output is `2 1`, not `1 1`.

- âŒ **2 2**
  - The variables are swapped, resulting in `x = 2` and `y = 1`. The output is not `2 2`.

### Explanation:
Variables are reassigned during the code execution. `z` temporarily holds the value of `x`, allowing the values of `x` and `y` to be swapped.

---

## What is the expected output of the following code?

```python
print(list('hello'))
```


**Domain:** Data Aggregates

### Options:
- âŒ **['h' 'e' 'l' 'l' 'o']**
  - The output must include commas between the elements to create a valid list. The correct output is `['h', 'e', 'l', 'l', 'o']`.

- âŒ **hello**
  - The `list()` function converts a string into a list of individual characters. The output is not the string `'hello'`.

- âœ… **['h', 'e', 'l', 'l', 'o']**
  - The `list()` function splits the string `'hello'` into a list of its characters: `['h', 'e', 'l', 'l', 'o']`.

- âŒ **None of the above.**
  - The correct output is `['h', 'e', 'l', 'l', 'o']`.

- âŒ **['h', 'e', 'l', 'l', 'o']**
  - Elements in a list must be quoted to be valid strings. The correct output is `['h', 'e', 'l', 'l', 'o']`.

### Explanation:
The `list()` function converts a string into a list of its characters. Each character becomes an individual string element in the list.

---

## What is the expected output of the following code?

```python
z = y = x = 1
print(x, y, z, sep='*')
```


**Domain:** Data Types

### Options:
- âŒ **1 1 1**
  - The `sep='*'` argument specifies that the values are separated by `*`, not spaces. The correct output is `1*1*1`.

- âœ… **1*1*1**
  - The `sep='*'` argument in the `print()` function separates the values with an asterisk. Since `x`, `y`, and `z` are all `1`, the output is `1*1*1`.

- âŒ **111***
  - The output separates values with `*`. It does not concatenate all values into a single string like `111*`.

- âŒ **x*y*z**
  - The output is not a mathematical expression. It simply prints the values separated by `*`.

### Explanation:
The `print()` function with the `sep` argument customizes the separator between values. Here, `sep='*'` results in `1*1*1`.

---

## If a list is passed into a function as an argument, deleting any of its elements inside the function using the `del` instruction:


**Domain:** Functions

### Options:
- âŒ **will not affect the argument**
  - Lists in Python are mutable. Any modification, including deleting elements, affects the original list passed as an argument.

- âœ… **will affect the argument**
  - Passing a list to a function creates a reference to the original list. Using `del` to delete elements modifies the original list.

- âŒ **will cause a runtime error**
  - The `del` instruction does not cause a runtime error. It modifies the list by removing elements.

### Explanation:
Lists are mutable, and functions receive references to the original object. Changes to the list, such as deleting elements, affect the original list.

---

## What is the expected output of the following code?

```python
def fun():
    return True
x = fun(False)
print(x)
```


**Domain:** Functions

### Options:
- âŒ **False**
  - The function `fun()` does not return `False`. It is defined to always return `True`.

- âŒ **0**
  - The function does not return an integer. It always returns a boolean value, specifically `True`.

- âœ… **The program will cause an error**
  - The program will raise a `TypeError` because `fun()` is defined without parameters, but it is called with one argument (`False`).

- âŒ **True**
  - The program does not execute successfully due to a `TypeError`. If the function were called correctly, it would return `True`.

- âŒ **1**
  - The function does not return an integer. It is defined to return `True`, but the program raises an error before reaching this point.

### Explanation:
The function `fun()` is defined without parameters, so calling it with an argument (`False`) causes a `TypeError`. Python does not allow extra arguments for functions with no defined parameters.

---

## What is the expected output of the following code?

```python
x = 1 / 2 + 3 // 3 + 4 ** 2
print(x)
```


**Domain:** Operators

### Options:
- âŒ **17**
  - The correct output is `17.5`. The division `1 / 2` results in `0.5`, which is added to the results of `3 // 3` and `4 ** 2`.

- âŒ **8.5**
  - The correct result is `17.5`. The division `1 / 2` contributes `0.5`, while `3 // 3` adds `1` and `4 ** 2` adds `16`.

- âŒ **8**
  - The output is not `8`. The sum of the evaluated expressions is `17.5`.

- âœ… **17.5**
  - The expression evaluates as follows:
- `1 / 2` is `0.5`
- `3 // 3` is `1`
- `4 ** 2` is `16`
Summing these values gives `17.5`.

### Explanation:
Python evaluates arithmetic expressions following operator precedence:
1. Exponentiation (`**`)
2. Division and floor division (`/`, `//`)
3. Addition (`+`)
The final result is `17.5`.

---

## Which of the following lines correctly invoke the function defined below:

```python
def fun(a, b, c=0):
    pass
```

(Select two answers)


**Domain:** Functions

### Options:
- âŒ **fun()**
  - The function requires at least two positional arguments (`a` and `b`). Calling it without arguments results in a `TypeError`.

- âœ… **fun(0, 1, 2)**
  - This correctly provides values for all parameters: `a=0`, `b=1`, and `c=2`. The default value of `c` is overridden by the provided value.

- âŒ **fun(b=1)**
  - The function requires at least two arguments, and only `b` is provided. This results in a `TypeError` for the missing argument `a`.

- âœ… **fun(b=0, a=0)**
  - This correctly uses keyword arguments to assign values to `a` and `b`. The default value of `c` remains `0`.

### Explanation:
The function requires at least two arguments (`a` and `b`). Providing these either positionally or using keywords is valid. The default value for `c` is used if no value is provided.

---

## What is the expected output of the following code?

```python
def func(num):
    res = '*'
    for _ in range(num):
        res += res
    return res

for x in func(2):
    print(x, end='')
```


**Domain:** Functions

### Options:
- âŒ ******
  - The function doubles the string in each loop iteration. For `num=2`, the string becomes `****`, not `**`.

- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. It correctly generates and prints the string `****`.

- âŒ *****
  - The function doubles the string in each iteration of the loop. For `num=2`, the result is `****`, not `*`.

- âœ… ********
  - The function generates a string by doubling `'*'` in each iteration. For `num=2`, the result is `'*' -> '**' -> '****'`.

### Explanation:
The function initializes `res` as `'*'` and doubles it in each iteration of the loop. After two iterations, `res` becomes `****`, which is printed character by character in the outer loop.

---

## How many stars will the following snippet print to the monitor?

```python
i = 4
while i > 0:
    i -= 2
    print('*')
    if i == 2:
        break
else:
    print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **2**
  - The loop breaks during the first iteration when `i` becomes `2`. Only one star is printed, and the `else` block is skipped.

- âŒ **0**
  - The loop runs at least once before the `break` statement. One star is printed.

- âœ… **1**
  - The loop prints one star during the first iteration before breaking when `i == 2`. The `else` block is not executed due to the `break`.

- âŒ **The snippet will enter an infinite loop.**
  - The loop condition ensures termination. The `break` statement exits the loop when `i == 2`.

### Explanation:
The `break` statement in the loop prevents the `else` block from executing. The loop runs once, printing a single star before terminating.

---

## What is the expected output of the following code snippet?

```python
nums = [3, 4, 5, 20, 5, 25, 1, 3]
nums.pop(1)
print(nums)
```


**Domain:** Data Aggregates

### Options:
- âŒ **[1, 3, 4, 5, 20, 5, 25]**
  - This is incorrect because `pop(1)` removes the second element (4) from the list. The resulting list is `[3, 5, 20, 5, 25, 1, 3]`.

- âŒ **[1, 3, 3, 4, 5, 5, 20, 25]**
  - The `pop()` method only removes an element; it does not duplicate or rearrange the list elements.

- âŒ **[3, 4, 5, 20, 5, 25, 1, 3]**
  - This is the original list. After the `pop()` operation, the element at index 1 is removed, resulting in a modified list.

- âœ… **[3, 5, 20, 5, 25, 1, 3]**
  - The `pop(1)` method removes the second element of the list (`4`). The modified list is `[3, 5, 20, 5, 25, 1, 3]`.

### Explanation:
The `pop()` method removes the element at the specified index and returns it. After `nums.pop(1)`, the second element (`4`) is removed, modifying the list.

---

## What is the expected output of the following code?

```python
x = '\''
print(len(x))
```


**Domain:** Basics

### Options:
- âŒ **The code is erroneous.**
  - The code is valid. The backslash (`\`) escapes the single quote, making it part of the string.

- âœ… **1**
  - The string contains one character: an escaped single quote (`'`). The `len()` function returns `1`.

- âŒ **2**
  - The length is not `2`. The backslash (`\`) is an escape character and does not count as a separate character.

- âŒ **0**
  - The string contains one character, so the length is not `0`.

### Explanation:
The backslash (`\`) is an escape character that allows special characters (e.g., `'`) to be included in strings. The length of the string is `1`.

---

## A function definition starts with the keyword:

```python
def my_function():
    pass
```


**Domain:** Functions

### Options:
- âŒ **fun**
  - `fun` is not a Python keyword. The correct keyword to define a function is `def`.

- âŒ **function**
  - `function` is not a Python keyword for defining functions. The keyword `def` is used instead.

- âœ… **def**
  - The keyword `def` is used in Python to define functions.

### Explanation:
In Python, functions are defined using the `def` keyword, followed by the function name, parameters (if any), and a colon (`:`).

---

## The result of the following addition:

```python
123 + 0.0
```


**Domain:** Operators

### Options:
- âŒ **is equal to 123**
  - Adding an integer and a float always results in a float. The output is `123.0`, not `123`.

- âœ… **is equal to 123.0**
  - The addition of an integer and a float promotes the result to a float. The correct result is `123.0`.

- âŒ **cannot be evaluated**
  - The operation is valid in Python and results in `123.0`.

### Explanation:
Python automatically converts integers to floats during arithmetic operations involving both types. Adding `123` (integer) and `0.0` (float) results in `123.0`.

---

## If a list is passed into a function as an argument, deleting any of its elements inside the function using the `del` instruction:


**Domain:** Functions

### Options:
- âŒ **will not affect the argument**
  - Lists in Python are mutable. Modifications inside a function affect the original list passed as an argument.

- âœ… **will affect the argument**
  - Lists are passed by reference in Python. Changes, including deletions, affect the original list.

- âŒ **will cause a runtime error**
  - The `del` instruction does not cause runtime errors when applied to a valid list index.

### Explanation:
Python passes mutable objects like lists by reference. Changes made inside a function, such as deleting elements, directly affect the original list.

---

## What is the expected output of the following code?

```python
def fun():
    return True
x = fun(False)
print(x)
```


**Domain:** Functions

### Options:
- âŒ **False**
  - The function `fun()` does not return `False`. It is defined to always return `True`.

- âŒ **0**
  - The function does not return an integer. It always returns a boolean value, specifically `True`.

- âœ… **The program will cause an error**
  - The program will raise a `TypeError` because `fun()` is defined without parameters, but it is called with one argument (`False`).

- âŒ **True**
  - The program does not execute successfully due to a `TypeError`. If the function were called correctly, it would return `True`.

- âŒ **1**
  - The function does not return an integer. It is defined to return `True`, but the program raises an error before reaching this point.

### Explanation:
The function `fun()` is defined without parameters, so calling it with an argument (`False`) causes a `TypeError`. Python does not allow extra arguments for functions with no defined parameters.

---

## What is the expected output of the following code?

```python
x = 1 / 2 + 3 // 3 + 4 ** 2
print(x)
```


**Domain:** Operators

### Options:
- âŒ **17**
  - The correct output is `17.5`. The division `1 / 2` results in `0.5`, which is added to the results of `3 // 3` and `4 ** 2`.

- âŒ **8.5**
  - The correct result is `17.5`. The division `1 / 2` contributes `0.5`, while `3 // 3` adds `1` and `4 ** 2` adds `16`.

- âŒ **8**
  - The output is not `8`. The sum of the evaluated expressions is `17.5`.

- âœ… **17.5**
  - The expression evaluates as follows:
- `1 / 2` is `0.5`
- `3 // 3` is `1`
- `4 ** 2` is `16`
Summing these values gives `17.5`.

### Explanation:
Python evaluates arithmetic expressions following operator precedence:
1. Exponentiation (`**`)
2. Division and floor division (`/`, `//`)
3. Addition (`+`)
The final result is `17.5`.

---

## Which of the following lines correctly invoke the function defined below:

```python
def fun(a, b, c=0):
    pass
```

(Select two answers)


**Domain:** Functions

### Options:
- âŒ **fun()**
  - The function requires at least two positional arguments (`a` and `b`). Calling it without arguments results in a `TypeError`.

- âœ… **fun(0, 1, 2)**
  - This correctly provides values for all parameters: `a=0`, `b=1`, and `c=2`. The default value of `c` is overridden by the provided value.

- âŒ **fun(b=1)**
  - The function requires at least two arguments, and only `b` is provided. This results in a `TypeError` for the missing argument `a`.

- âœ… **fun(b=0, a=0)**
  - This correctly uses keyword arguments to assign values to `a` and `b`. The default value of `c` remains `0`.

### Explanation:
The function requires at least two arguments (`a` and `b`). Providing these either positionally or using keywords is valid. The default value for `c` is used if no value is provided.

---

## What is the expected output of the following code?

```python
def func(num):
    res = '*'
    for _ in range(num):
        res += res
    return res

for x in func(2):
    print(x, end='')
```


**Domain:** Functions

### Options:
- âŒ ******
  - The function doubles the string in each loop iteration. For `num=2`, the string becomes `****`, not `**`.

- âŒ **The code is erroneous.**
  - The code is valid and executes without errors. It correctly generates and prints the string `****`.

- âŒ *****
  - The function doubles the string in each iteration of the loop. For `num=2`, the result is `****`, not `*`.

- âœ… ********
  - The function generates a string by doubling `'*'` in each iteration. For `num=2`, the result is `'*' -> '**' -> '****'`.

### Explanation:
The function initializes `res` as `'*'` and doubles it in each iteration of the loop. After two iterations, `res` becomes `****`, which is printed character by character in the outer loop.

---

## How many stars will the following snippet print to the monitor?

```python
i = 4
while i > 0:
    i -= 2
    print('*')
    if i == 2:
        break
else:
    print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **2**
  - The loop breaks during the first iteration when `i` becomes `2`. Only one star is printed, and the `else` block is skipped.

- âŒ **0**
  - The loop runs at least once before the `break` statement. One star is printed.

- âœ… **1**
  - The loop prints one star during the first iteration before breaking when `i == 2`. The `else` block is not executed due to the `break`.

- âŒ **The snippet will enter an infinite loop.**
  - The loop condition ensures termination. The `break` statement exits the loop when `i == 2`.

### Explanation:
The `break` statement in the loop prevents the `else` block from executing. The loop runs once, printing a single star before terminating.

---

## What is the expected behavior of the following program?

```python
try:
    print(5/0)
    break
except:
    print("Sorry, something went wrong...")
except (ValueError, ZeroDivisionError):
    print("Too bad...")
```


**Domain:** Error Handling

### Options:
- âŒ **The program will cause a ValueError exception and output a default error message.**
  - The program does not involve a ValueError-related operation. Instead, it attempts to divide by zero, but a SyntaxError occurs first due to the `break` statement being outside of a loop.

- âŒ **The program will raise an exception handled by the first except block.**
  - The program will not reach any exception handling due to the `break` statement causing a SyntaxError before any exception occurs.

- âœ… **The program will cause a SyntaxError exception.**
  - The program causes a SyntaxError because the `break` statement is used outside of a loop. Additionally, the general `except` block is placed before the specific `except` block, which is another syntax issue in Python.

- âŒ **The program will cause a ZeroDivisionError exception and output a default error message.**
  - The program does attempt to divide by zero, which would raise a ZeroDivisionError, but this is never reached due to the SyntaxError caused by the `break` statement.

- âŒ **The program will cause a ValueError exception and output the following message: 'Too bad...'**
  - A ValueError is not raised in the program. Instead, a SyntaxError prevents the program from executing the exception handling logic.

### Explanation:
The program contains multiple syntax issues. The `break` statement is used outside of a loop, which is not allowed in Python. Additionally, the general `except` block must always appear after specific exception handlers. These errors cause a SyntaxError before the program can execute.

---

## What are the four fundamental elements that make a language?


**Domain:** Basics

### Options:
- âŒ **An alphabet, phonetics, phonology, and semantics**
  - While phonetics and semantics are important for understanding natural languages, phonology and phonetics are not core components of all languages. Syntax and lexis are fundamental elements for programming and structured languages.

- âœ… **An alphabet, a lexis, a syntax, and semantics**
  - An alphabet defines the symbols of a language, lexis refers to vocabulary, syntax dictates the structure, and semantics provides the meaning of sentences and phrases.

- âŒ **An alphabet, morphology, phonetics, and semantics**
  - Morphology is not considered one of the four fundamental elements that define a language. Syntax and lexis are more relevant to both natural and programming languages.

- âŒ **An alphabet, a lexis, phonetics, and semantics**
  - Phonetics deals with the sounds of speech and is not a core element in the structure of all languages, particularly programming languages.

### Explanation:
The four fundamental elements of a language include:
- **Alphabet:** A set of symbols (letters, numbers, etc.).
- **Lexis:** The vocabulary or dictionary of the language.
- **Syntax:** Rules for arranging symbols to create valid expressions.
- **Semantics:** The meaning conveyed by the symbols and their arrangement.

---

## What is the expected behavior of the following program?

```python
try:
    print(5/0)
    break
except:
    print("Sorry, something went wrong...")
except (ValueError, ZeroDivisionError):
    print("Too bad...")
```


**Domain:** Error Handling

### Options:
- âŒ **The program will cause a ValueError exception and output a default error message.**
  - The program does not contain any ValueError-related operations, so it will not cause a ValueError exception.

- âŒ **The program will raise an exception handled by the first except block.**
  - The program will not raise an exception handled by the first except block. The 'break' statement will cause a SyntaxError before any exceptions are raised.

- âœ… **The program will cause a SyntaxError exception.**
  - The program will cause a SyntaxError exception because the 'break' statement is used outside of a loop, which is a syntax error in Python.

- âŒ **The program will cause a ZeroDivisionError exception and output a default error message.**
  - The program will cause a SyntaxError exception because the 'break' statement is used outside of a loop, which is a syntax error in Python.

- âŒ **The program will cause a ValueError exception and output the following message: "Too bad..."**
  - The program will not output the message "Too bad..." because it contains a SyntaxError due to the use of 'break' outside a loop.

### Explanation:
The program has two issues:
1. The 'break' statement is used outside of a loop, which is a syntax error.
2. The first except block must be placed last if it is a general exception handler.

---

## What is the output of the following code snippet?

```python
d = {}
d[1] = 1
d['1'] = 2
d[1] += 1

sum = 0

for k in d:
    sum += d[k]

print(sum)
```


**Domain:** Data Aggregates

### Options:
- âŒ **1**
  - The value of key '1' in the dictionary is 2, and the value of key 1 is incremented to 2. Thus, the total sum is 4.

- âŒ **2**
  - The sum of the dictionary values is not 2. The values are incremented correctly to result in a sum of 4.

- âœ… **4**
  - The dictionary has keys 1 and '1' with values 2 each after the operations. The sum of all values is 2 + 2 = 4.

- âŒ **3**
  - The sum of the dictionary values is not 3. The values after operations sum up to 4.

### Explanation:
In Python, dictionaries can have keys of different data types. Here, `1` and `'1'` are treated as separate keys. The value for key `1` is incremented to 2, and the sum of all values in the dictionary is 4.

---

## What is the expected output of the following code?

```python
def func(p1, p2):
    p1 = 1
    p2[0] = 42

x = 3
y = [1, 2, 3]

func(x, y)

print(x, y[0])
```


**Domain:** Functions

### Options:
- âŒ **The code is erroneous.**
  - The code runs without errors. It demonstrates the difference between mutable and immutable data types in Python.

- âœ… **3 42**
  - `x` is an integer (immutable) and remains unchanged. `y` is a list (mutable), so changes to it inside the function are reflected in the original list.

- âŒ **1 42**
  - The value of `x` is not modified outside the function because integers are immutable in Python.

- âŒ **3 1**
  - The first element of `y` is modified inside the function to 42, so the output is not `3 1`.

- âŒ **1 1**
  - The list `y` is modified, and the first element becomes 42. The integer `x` remains unchanged.

### Explanation:
This code highlights the difference between mutable and immutable types. Integers are immutable, so assigning `p1 = 1` does not affect `x`. Lists are mutable, so modifying `p2[0]` changes the original list `y`.

---

## How many stars will the following code print to the monitor?

```python
i = 0
while i <= 3:
    i += 2
    print('*')
```


**Domain:** Control Flow

### Options:
- âŒ **one**
  - The loop increments `i` by 2 each time and prints a star in each iteration. It runs twice, not once.

- âœ… **two**
  - The loop runs twice: first with `i = 0` and then with `i = 2`. Each time, it prints a star. The loop ends when `i = 4`.

- âŒ **three**
  - The loop does not run three times. It only runs for `i = 0` and `i = 2`, printing two stars in total.

- âŒ **zero**
  - The loop runs twice and prints two stars, so the output is not zero stars.

### Explanation:
The loop runs twice: once with `i = 0` and once with `i = 2`. On each iteration, a star is printed. The loop stops when `i` exceeds 3.

---

## What is the expected output of the following code?

```python
def func(data):
    for d in data[::2]:
        yield d

for x in func('abcdef'):
    print(x, end='')
```


**Domain:** Functions

### Options:
- âœ… **ace**
  - The function iterates over every second character in the string 'abcdef' and yields 'a', 'c', and 'e', which are printed without spaces.

- âŒ **An empty line.**
  - The function yields characters 'a', 'c', and 'e', so the output is not an empty line.

- âŒ **bdf**
  - The slicing `[::2]` selects every second character starting with the first, so the output is not 'bdf'.

- âŒ **abcdef**
  - The function does not iterate over every character. It selects every second character, resulting in 'ace'.

### Explanation:
The slicing `[::2]` selects every second character from the string 'abcdef'. The generator yields these characters, and they are printed as 'ace'.

---
