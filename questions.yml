questions:
- domain: Operators
  options:
  - answer: None
    correct: false
    explanation: The output will not be None because the logical operation evaluates
      to a boolean value.
  - answer: The program will cause an error
    correct: false
    explanation: There are no syntax errors in the program.
  - answer: 'True'
    correct: true
    explanation: The expression 'a > b' evaluates to False, and 'not False' is True.
  - answer: 'False'
    correct: false
    explanation: The expression 'a > b' evaluates to False, but 'not False' results
      in True.
  overall_explanation: The 'not' operator inverts the boolean value, leading to True.
  question: 'What is the output of the following code?


    a = 10

    b = 20

    c = a > b

    print(not(c))'
- domain: Data Types
  options:
  - answer: The None value can be compared with variables.
    correct: false
    explanation: None can be compared with variables, often to check if a value has
      been assigned.
  - answer: The None value may not be used outside functions.
    correct: true
    explanation: None can be used anywhere in Python, not just inside functions.
  - answer: The None value can be assigned to variables.
    correct: false
    explanation: None can be assigned to variables to indicate a lack of value.
  - answer: The None value cannot be used as an argument of arithmetic operators.
    correct: false
    explanation: Using None in arithmetic operations results in a TypeError.
  overall_explanation: None is a built-in constant representing the absence of a value
    and can be used globally.
  question: Which of the following statements is false?
- domain: Functions
  options:
  - answer: The code is erroneous.
    correct: false
    explanation: The code correctly modifies a dictionary and does not contain errors.
  - answer: '2'
    correct: false
    explanation: Keys are case-sensitive, so there are three unique entries.
  - answer: '3'
    correct: true
    explanation: 'The dictionary stores three unique keys: ''Peter'', ''Paul'', and
      ''peter''.'
  - answer: '1'
    correct: false
    explanation: Each call to add_person adds a unique key to the dictionary.
  overall_explanation: Dictionary keys are case-sensitive, so 'Peter' and 'peter'
    are distinct.
  question: "What is the expected output of the following code?\n\npeople = {}\n\n\
    def add_person(index):\n    if index in people:\n        people[index] += 1\n\
    \    else:\n        people[index] = 1\n\nadd_person('Peter')\nadd_person('Paul')\n\
    add_person('peter')\n\nprint(len(people))"
- domain: Control Flow
  options:
  - answer: res is the sum of all numbers in the list.
    correct: false
    explanation: No summation occurs in this code.
  - answer: res is the average of all numbers in the list.
    correct: false
    explanation: No division is performed to calculate an average.
  - answer: res is the smallest number in the list.
    correct: true
    explanation: The loop iterates and updates res to store the smallest number.
  - answer: res is the largest number in the list.
    correct: false
    explanation: The logic updates res to hold the smallest value, not the largest.
  overall_explanation: This code finds and prints the smallest number in the list.
  question: "What is the expected output of the following code?\n\ndata = [4, 2, 3,\
    \ 2, 1]\nres = data[0]\n\nfor d in data:\n    if d < res:\n        res = d\n\n\
    print(res)"
- domain: Control Flow
  options:
  - answer: zero
    correct: false
    explanation: The loop does execute, but it results in an infinite loop.
  - answer: one
    correct: false
    explanation: The loop will not exit, leading to an infinite loop.
  - answer: two
    correct: false
    explanation: The loop does not execute normally; it runs indefinitely.
  - answer: The snippet will enter an infinite loop.
    correct: true
    explanation: Since i is always smaller than i + 2, the condition never fails.
  overall_explanation: The while condition always evaluates to true, creating an infinite
    loop.
  question: "How many stars will the following code print?\n\ni = 0\nwhile i < i +\
    \ 2:\n    i += 1\n    print('*')\nelse:\n    print('*')"
- domain: Data Aggregates
  options:
  - answer: print(k[0])
    correct: true
    explanation: Each value in the dictionary is a tuple, so we access the first element.
  - answer: print(k['0'])
    correct: false
    explanation: Tuples use integer indexing, not string keys.
  - answer: print(k['0'])
    correct: false
    explanation: Tuples require numerical indices.
  - answer: print(k)
    correct: false
    explanation: This would print the entire tuple instead of just the expected character.
  overall_explanation: The dictionary stores tuples, so accessing k[0] correctly extracts
    the expected value.
  question: "What code would you insert to obtain the expected output?\n\ndictionary\
    \ = {}\nmy_list = ['a', 'b', 'c', 'd']\n\nfor i in range(len(my_list) - 1):\n\
    \    dictionary[my_list[i]] = (my_list[i], )\n\nfor i in sorted(dictionary.keys()):\n\
    \    k = dictionary[i]\n    # Insert your code here."
- domain: Functions
  options:
  - answer: Peter
    correct: false
    explanation: The function modifies the dictionary but does not return a value.
  - answer: None
    correct: true
    explanation: Since func() has no return statement, it implicitly returns None.
  - answer: The code is erroneous.
    correct: false
    explanation: The function correctly modifies the dictionary.
  - answer: value
    correct: false
    explanation: The function does not return any value.
  overall_explanation: Functions without an explicit return statement return None.
  question: "What is the expected output of the following code?\n\ndata = {}\n\ndef\
    \ func(d, key, value):\n    d[key] = value\n\nprint(func(data, '1', 'Peter'))"
- domain: Functions
  options:
  - answer: '9'
    correct: false
    explanation: The function does not execute due to a syntax error.
  - answer: '6'
    correct: false
    explanation: The function cannot execute due to invalid syntax.
  - answer: The snippet is erroneous (invalid syntax)
    correct: true
    explanation: Using 'in' as a parameter name is invalid in Python.
  overall_explanation: '''in'' is a reserved keyword in Python and cannot be used
    as a parameter name.'
  question: "What is the output of the following snippet?\n\ndef fun(in=2, out=3):\n\
    \    return in * out\n\nprint(fun(3))"
- domain: Control Flow
  options:
  - answer: '10'
    correct: false
    explanation: The ternary operator evaluates to the larger value, which is 20.
  - answer: '20'
    correct: true
    explanation: Since x is not greater than y, z is assigned the value of y (20).
  - answer: None
    correct: false
    explanation: The ternary operator ensures a value is always assigned.
  - answer: Error
    correct: false
    explanation: The code is syntactically correct.
  overall_explanation: A ternary operator selects one of two values based on a condition.
  question: 'What is the expected output of the following code?


    x = 10

    y = 20

    z = x if x > y else y

    print(z)'
- domain: Functions
  options:
  - answer: '[1]

      [1]

      [1]'
    correct: false
    explanation: Default mutable arguments persist between function calls.
  - answer: '[1]

      [1, 1]

      [1, 1, 1]'
    correct: true
    explanation: Each function call appends to the same list.
  - answer: '[]

      []

      []'
    correct: false
    explanation: The list is modified, so it doesn't remain empty.
  - answer: None
    correct: false
    explanation: The function prints a list and does not return None.
  overall_explanation: Using a mutable default argument results in persistent modifications
    across function calls.
  question: "What is the expected output of the following code?\n\ndef func(x=[]):\n\
    \    x.append(1)\n    print(x)\n\nfunc()\nfunc()\nfunc()"
- domain: Data Aggregates
  options:
  - answer: KeyError
    correct: false
    explanation: Using .get() prevents a KeyError and returns a default value instead.
  - answer: None
    correct: false
    explanation: The default value specified is 3, not None.
  - answer: '3'
    correct: true
    explanation: Since 'c' is not in the dictionary, the default value 3 is returned.
  - answer: Error
    correct: false
    explanation: The code executes successfully.
  overall_explanation: The .get() method returns a specified default value when a
    key is not found.
  question: 'What will be the output of the following code?


    x = {''a'': 1, ''b'': 2}

    print(x.get(''c'', 3))'
- domain: Data Aggregates
  options:
  - answer: Tuples are mutable.
    correct: false
    explanation: Tuples are immutable and cannot be modified after creation.
  - answer: Tuples can contain elements of different data types.
    correct: true
    explanation: Tuples, like lists, can store different data types.
  - answer: Tuples must contain at least one element.
    correct: false
    explanation: Tuples can be empty.
  - answer: Tuples and lists are the same.
    correct: false
    explanation: Lists are mutable, while tuples are immutable.
  overall_explanation: Tuples can store different data types but are immutable, unlike
    lists.
  question: Which of the following statements about Python tuples is true?
- domain: Data Aggregates
  options:
  - answer: '{1, 2, 2, 3, 3, 3}'
    correct: false
    explanation: Sets do not allow duplicate values.
  - answer: '{1, 2, 3}'
    correct: true
    explanation: Sets store only unique elements.
  - answer: '[1, 2, 3]'
    correct: false
    explanation: Sets use curly braces, not square brackets.
  - answer: Error
    correct: false
    explanation: The expression is valid and returns a set.
  overall_explanation: Sets automatically remove duplicate values.
  question: What does the expression `set([1, 2, 2, 3, 3, 3])` return?
- domain: Data Aggregates
  options:
  - answer: '[3, 2, 1]'
    correct: true
    explanation: The slicing syntax `[::-1]` reverses the list.
  - answer: '[1, 2, 3]'
    correct: false
    explanation: The slicing modifies the order.
  - answer: Error
    correct: false
    explanation: The syntax is valid.
  - answer: None
    correct: false
    explanation: The function returns a new reversed list, not None.
  overall_explanation: Slicing with `[::-1]` reverses the order of list elements.
  question: 'What is the expected output of the following code?


    x = [1, 2, 3]

    print(x[::-1])'
- domain: Data Aggregates
  options:
  - answer: 'True'
    correct: false
    explanation: '''c'' is not a key in the dictionary.'
  - answer: 'False'
    correct: true
    explanation: Since 'c' is not a key, the expression evaluates to False.
  - answer: None
    correct: false
    explanation: The expression evaluates to a boolean value.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: Using the `in` operator checks for the presence of a key in
    a dictionary.
  question: 'What will be the output of the following code?


    x = {''a'': 1, ''b'': 2}

    print(''c'' in x)'
- domain: Data Aggregates
  options:
  - answer: Dictionary keys must be integers.
    correct: false
    explanation: Keys can be any immutable data type.
  - answer: Dictionaries preserve the insertion order of elements.
    correct: true
    explanation: Since Python 3.7, dictionaries maintain insertion order.
  - answer: Dictionaries allow duplicate keys.
    correct: false
    explanation: Each key in a dictionary must be unique.
  - answer: Dictionaries are immutable.
    correct: false
    explanation: Dictionaries are mutable and can be modified.
  overall_explanation: Dictionaries maintain key-value pairs and preserve insertion
    order.
  question: Which of the following statements about Python dictionaries is true?
- domain: Boolean Logic
  options:
  - answer: 'False'
    correct: false
    explanation: Any non-empty string evaluates to True in a boolean context.
  - answer: 'True'
    correct: true
    explanation: Since 'False' is a non-empty string, it evaluates to True.
  - answer: None
    correct: false
    explanation: The bool() function does not return None.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: In Python, any non-empty string evaluates to True when passed
    to the bool() function.
  question: 'What is the expected output of the following code?


    print(bool(''False''))'
- domain: Control Flow
  options:
  - answer: A for loop can only iterate over lists.
    correct: false
    explanation: For loops can iterate over any iterable, including tuples and strings.
  - answer: A while loop runs until a specified condition is False.
    correct: true
    explanation: While loops continue executing as long as the condition remains True.
  - answer: Break statements do not work in loops.
    correct: false
    explanation: Break statements terminate loops early.
  - answer: Continue statements exit the loop.
    correct: false
    explanation: Continue statements skip the current iteration but do not exit the
      loop.
  overall_explanation: While loops execute as long as a condition remains True.
  question: Which of the following statements about Python loops is true?
- domain: Boolean Logic
  options:
  - answer: 'True'
    correct: false
    explanation: An empty string evaluates to False in a boolean context.
  - answer: 'False'
    correct: true
    explanation: Empty strings evaluate to False when converted to a boolean.
  - answer: None
    correct: false
    explanation: The bool function does not return None.
  - answer: Error
    correct: false
    explanation: The expression is valid and executes correctly.
  overall_explanation: Empty strings evaluate to False when converted to a boolean.
  question: What does the expression `bool('')` evaluate to?
- domain: Data Aggregates
  options:
  - answer: Strings are mutable.
    correct: false
    explanation: Strings in Python are immutable.
  - answer: Strings can be indexed and sliced.
    correct: true
    explanation: Python allows indexing and slicing of string elements.
  - answer: Strings must always be lowercase.
    correct: false
    explanation: Strings can contain uppercase, lowercase, or mixed-case characters.
  - answer: Strings are the same as lists.
    correct: false
    explanation: Strings are sequences, but they are immutable, unlike lists.
  overall_explanation: Python strings can be indexed and sliced but are immutable.
  question: Which of the following statements about Python strings is true?
- domain: Data Aggregates
  options:
  - answer: '0'
    correct: false
    explanation: The list contains one element, which is an empty list.
  - answer: '1'
    correct: true
    explanation: The list contains a single element, an empty list, so its length
      is 1.
  - answer: None
    correct: false
    explanation: The len() function does not return None.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: len([[]]) returns 1 because the outer list contains one element
    (an empty list).
  question: 'What does the following code output?


    print(len([[]]))'
- domain: Data Aggregates
  options:
  - answer: <class 'dict'>
    correct: true
    explanation: An empty {} creates an empty dictionary in Python.
  - answer: <class 'set'>
    correct: false
    explanation: An empty set is created using `set()`, not `{}`.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  - answer: None
    correct: false
    explanation: The type() function returns the type, not None.
  overall_explanation: An empty `{}` in Python represents an empty dictionary.
  question: 'What is the expected output of the following code?


    print(type({}))'
- domain: Data Aggregates
  options:
  - answer: Lists must contain elements of the same type.
    correct: false
    explanation: Lists can contain elements of different types.
  - answer: Lists are immutable.
    correct: false
    explanation: Lists are mutable and can be modified.
  - answer: Lists are ordered collections.
    correct: true
    explanation: Lists maintain the order of their elements.
  - answer: Lists do not support indexing.
    correct: false
    explanation: Lists support indexing and slicing.
  overall_explanation: Lists are ordered collections and maintain the order of elements.
  question: Which of the following statements about Python lists is true?
- domain: Boolean Logic
  options:
  - answer: 'True'
    correct: false
    explanation: None evaluates to False in a boolean context.
  - answer: 'False'
    correct: true
    explanation: None is considered a falsy value in Python.
  - answer: None
    correct: false
    explanation: The bool function does not return None.
  - answer: Error
    correct: false
    explanation: The expression is valid and evaluates to False.
  overall_explanation: None evaluates to False when converted to a boolean.
  question: What does the expression `bool(None)` evaluate to?
- domain: Boolean Logic
  options:
  - answer: 'True'
    correct: false
    explanation: Empty lists evaluate to False in a boolean context.
  - answer: 'False'
    correct: true
    explanation: Empty collections such as lists evaluate to False.
  - answer: None
    correct: false
    explanation: The bool function does not return None.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: Empty collections, including lists, evaluate to False when
    converted to a boolean.
  question: 'What is the expected output of the following code?


    print(bool([]))'
- domain: Data Aggregates
  options:
  - answer: '4'
    correct: false
    explanation: The string contains 5 characters.
  - answer: '5'
    correct: true
    explanation: The len() function counts the number of characters in the string.
  - answer: None
    correct: false
    explanation: The len() function does not return None.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: The len() function returns the number of characters in a string.
  question: 'What is the output of the following code?


    print(len(''Hello''))'
- domain: Data Aggregates
  options:
  - answer: <class 'list'>
    correct: true
    explanation: An empty [] represents an empty list in Python.
  - answer: <class 'dict'>
    correct: false
    explanation: '{} represents an empty dictionary, not a list.'
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  - answer: None
    correct: false
    explanation: The type() function returns the type, not None.
  overall_explanation: The square brackets [] in Python denote an empty list.
  question: 'What does the following code print?


    print(type([]))'
- domain: Boolean Logic
  options:
  - answer: 'True'
    correct: false
    explanation: Zero evaluates to False in a boolean context.
  - answer: 'False'
    correct: true
    explanation: Numbers other than zero evaluate to True, but zero evaluates to False.
  - answer: None
    correct: false
    explanation: The bool() function does not return None.
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  overall_explanation: The integer 0 evaluates to False in a boolean context.
  question: 'What will be the output of the following code?


    print(bool(0))'
- domain: Boolean Logic
  options:
  - answer: 'True'
    correct: true
    explanation: All non-zero numbers evaluate to True in a boolean context.
  - answer: 'False'
    correct: false
    explanation: Only zero evaluates to False.
  - answer: None
    correct: false
    explanation: The bool function does not return None.
  - answer: Error
    correct: false
    explanation: The expression is valid and executes correctly.
  overall_explanation: Any nonzero number evaluates to True when converted to a boolean.
  question: What does the expression `bool(1)` evaluate to?
- domain: Data Aggregates
  options:
  - answer: <class 'set'>
    correct: true
    explanation: Calling set() creates an empty set.
  - answer: <class 'dict'>
    correct: false
    explanation: '{} creates an empty dictionary, not a set.'
  - answer: Error
    correct: false
    explanation: The code executes correctly.
  - answer: None
    correct: false
    explanation: The type() function returns the type, not None.
  overall_explanation: Calling set() explicitly creates an empty set.
  question: 'What does the following code print?


    print(type(set()))'
- domain: Control Flow
  options:
  - answer: three
    correct: true
    explanation: Since n == 1 is True and n == True is also True, both if blocks execute.
  - answer: two
    correct: false
    explanation: Both the first and second if blocks execute, printing three stars
      in total.
  - answer: one
    correct: false
    explanation: More than one star is printed.
  - answer: six
    correct: false
    explanation: The program does not print six stars.
  overall_explanation: Python treats 1 as equivalent to True in boolean comparisons.
  question: "How many stars will the following code output?\n\n```python\nn = 1\n\
    if n == 1:\n    print('*')\nif n == True:\n    print('**')\nif n == False:\n \
    \   print('***')\n```"
- domain: Control Flow
  options:
  - answer: zero
    correct: false
    explanation: The loop executes at least once before breaking.
  - answer: three
    correct: false
    explanation: The loop does not reach three iterations before breaking.
  - answer: two
    correct: false
    explanation: The loop does not reach two iterations before breaking.
  - answer: one
    correct: true
    explanation: The loop prints one star before breaking when i reaches 2.
  overall_explanation: The loop prints one star before encountering the break condition.
  question: "How many stars will the following code print?\n\n```python\ni = 0\nwhile\
    \ i <= 5:\n    i += 1\n    if i % 2 == 0:\n        break\n    print('*')\n```"
- domain: Data Aggregates
  options:
  - answer: '0'
    correct: false
    explanation: The set is not empty.
  - answer: '3'
    correct: false
    explanation: The set contains four unique elements.
  - answer: '10'
    correct: false
    explanation: The set automatically removes duplicates.
  - answer: '4'
    correct: true
    explanation: The set contains the unique elements {1, 2, 3, 4}, so its length
      is 4.
  overall_explanation: Sets automatically remove duplicate values, keeping only unique
    elements.
  question: 'What is the expected output of the following code?


    ```python

    data = set([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])

    print(len(data))

    ```'
- domain: Data Types
  options:
  - answer: PeterWellert
    correct: true
    explanation: Adjacent string literals are automatically concatenated in Python.
  - answer: Wellert
    correct: false
    explanation: The first string is not removed.
  - answer: The code is erroneous.
    correct: false
    explanation: Python allows adjacent string literals to be concatenated.
  - answer: Peter
    correct: false
    explanation: Both string literals are concatenated into one.
  overall_explanation: In Python, adjacent string literals are automatically concatenated.
  question: 'What is the expected output of the following code?


    ```python

    print(''Peter'' ''Wellert'')

    ```'
- domain: Data Aggregates
  options:
  - answer: employees[0:-4]
    correct: false
    explanation: This removes only four elements, leaving one manager in the list.
  - answer: employees[1:-4]
    correct: false
    explanation: This removes four elements but also excludes the first employee.
  - answer: employees[1:-5]
    correct: false
    explanation: This removes the first employee as well as the five managers.
  - answer: employees[0:-5]
    correct: true
    explanation: This removes exactly the last five elements, leaving all non-managers.
  - answer: employees[:-5]
    correct: true
    explanation: The default start index (0) removes only the last five elements,
      which are the managers.
  overall_explanation: Using negative slicing removes a set number of elements from
    the end of the list.
  question: You develop a Python application for your company. A list named `employees`
    contains 200 employee names, the last five being company management. You need
    to slice the list to display all employees excluding management. Which code segments
    can you use? Choose two.
- domain: Data Aggregates
  options:
  - answer: 1 5 9 13
    correct: false
    explanation: This would happen if `.pop(0)` was used instead of `.pop()`.
  - answer: 1 2 3 4
    correct: false
    explanation: This would be correct if we printed the first element of each sublist
      instead of popping.
  - answer: 13 14 15 16
    correct: false
    explanation: This would occur if we accessed the last row instead of popping from
      all rows.
  - answer: 4 8 12 16
    correct: true
    explanation: Each `.pop()` removes and prints the last element from each row.
  overall_explanation: The `.pop()` method removes and returns the last element of
    each list.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14,\
    \ 15, 16]\n]\nfor i in range(0, 4):\n    print(data[i].pop(), end=' ')\n```"
- domain: Data Aggregates
  options:
  - answer: The code is erroneous.
    correct: false
    explanation: The syntax is correct and executes without errors.
  - answer: '[4, 3, 2, 1]'
    correct: false
    explanation: The slicing excludes index `0`, so `1` is not included.
  - answer: '[4, 3]'
    correct: false
    explanation: The slicing includes more than just `[4, 3]`.
  - answer: '[4, 3, 2]'
    correct: true
    explanation: The slice starts at index 3 (`4`) and moves backwards, excluding
      index 0.
  overall_explanation: The slice `[3:0:-1]` starts at index 3 (`4`), moves backwards,
    and stops before index 0.
  question: 'What is the expected output of the following code?


    ```python

    a = [1, 2, 3, 4, 5]

    print(a[3:0:-1])

    ```'
- domain: Control Flow
  options:
  - answer: one
    correct: false
    explanation: The loop executes multiple times, not just once.
  - answer: four
    correct: true
    explanation: The loop runs while `x` is less than 10, iterating four times (`1,
      2, 4, 8`).
  - answer: two
    correct: false
    explanation: The loop runs more than twice.
  - answer: eight
    correct: false
    explanation: The loop exits before reaching eight iterations.
  overall_explanation: The left shift operator (`<<`) doubles `x` each iteration,
    leading to four loops before exiting.
  question: "How many stars will the following code print to the monitor?\n\n```python\n\
    x = 1\nwhile x < 10:\n    print('*')\n    x = x << 1\n```"
- domain: Control Flow
  options:
  - answer: zero
    correct: false
    explanation: The loop executes indefinitely.
  - answer: one
    correct: false
    explanation: The condition ensures the loop never terminates.
  - answer: two
    correct: false
    explanation: The loop does not stop after two iterations.
  - answer: The snippet will enter an infinite loop.
    correct: true
    explanation: Since `i < i + 2` is always true, the loop never exits.
  overall_explanation: The loop condition never becomes false, leading to an infinite
    loop.
  question: "What is the expected output of the following code?\n\n```python\ni =\
    \ 0\nwhile i < i + 2:\n    i += 1\n    print('*')\nelse:\n    print('*')\n```"
- domain: Operators
  options:
  - answer: '4'
    correct: false
    explanation: The expression evaluates to a float, not an integer.
  - answer: '3'
    correct: false
    explanation: The floating-point division results in a decimal value.
  - answer: '3.5'
    correct: true
    explanation: The expression evaluates as `1 + 0 + 0.5 + 2 = 3.5`.
  - answer: '4.0'
    correct: false
    explanation: The correct result is `3.5`, not `4.0`.
  overall_explanation: Python follows operator precedence, and division operations
    produce a floating-point result.
  question: 'What is the expected output of the following code?


    ```python

    x = 1 + 1 // 2 + 1 / 2 + 2

    print(x)

    ```'
- domain: Basics
  options:
  - answer: print
    correct: false
    explanation: Although `print` is a built-in function, it can be reassigned as
      a variable name without causing a SyntaxError.
  - answer: in
    correct: true
    explanation: '`in` is a reserved keyword in Python and cannot be used as a variable
      name.'
  - answer: In
    correct: false
    explanation: '`In` is not a reserved keyword in Python. Python is case-sensitive,
      so `In` is different from `in`.'
  - answer: for
    correct: true
    explanation: '`for` is a reserved keyword in Python and cannot be used as a variable
      name.'
  overall_explanation: Reserved keywords in Python cannot be used as variable names.
  question: 'Which of the following variable names are illegal and will cause the
    SyntaxError exception?


    (Select two answers)'
- domain: Data Aggregates
  options:
  - answer: The code is erroneous.
    correct: true
    explanation: The list `data` has only two elements (`data[0]` and `data[1]`),
      so accessing `data[2]` causes an IndexError.
  - answer: '0'
    correct: false
    explanation: The code does not successfully access `data[2]` as it does not exist.
  - answer: '1'
    correct: false
    explanation: The code does not successfully access `data[2]` as it does not exist.
  - answer: '2'
    correct: false
    explanation: The code does not successfully access `data[2]` as it does not exist.
  overall_explanation: The `range(2)` in the list comprehension means `data` contains
    only two lists (`data[0]` and `data[1]`). Accessing `data[2]` results in an IndexError.
  question: 'What is the expected output of the following code?


    ```python

    data = [[0, 1, 2, 3] for i in range(2)]

    print(data[2][0])

    ```'
- domain: Functions
  options:
  - answer: must be placed before the first invocation
    correct: true
    explanation: Python executes code sequentially, so a function must be defined
      before it is called.
  - answer: may be placed anywhere inside the code after the first invocation
    correct: false
    explanation: Python requires a function to be defined before it is used, otherwise
      a NameError occurs.
  - answer: cannot be placed among other code
    correct: false
    explanation: A function definition can be placed among other code as long as it
      is defined before being called.
  overall_explanation: Functions must be defined before they are used in Python, as
    the interpreter processes code line by line.
  question: 'A function definition:'
- domain: Basics
  options:
  - answer: tRUE
    correct: false
    explanation: Python is case-sensitive, so `tRUE` is a valid variable name.
  - answer: 'TRUE'
    correct: false
    explanation: '`TRUE` is not a reserved keyword in Python, so it can be used as
      a variable name.'
  - answer: 'true'
    correct: false
    explanation: '`true` is not a reserved keyword in Python and can be used as a
      variable name.'
  - answer: 'True'
    correct: true
    explanation: '`True` is a reserved keyword in Python and cannot be used as a variable
      name.'
  overall_explanation: Python reserves certain keywords like `True`, `False`, and
    `None`, which cannot be used as variable names.
  question: Which of the following variable names is illegal?
- domain: Operators
  options:
  - answer: does not exist
    correct: false
    explanation: The `**` operator exists in Python and is used for exponentiation.
  - answer: performs duplicated multiplication
    correct: false
    explanation: The `**` operator performs exponentiation, not repeated multiplication.
  - answer: performs floating-point multiplication
    correct: false
    explanation: The `**` operator performs exponentiation, not floating-point multiplication.
  - answer: performs exponentiation
    correct: true
    explanation: The `**` operator raises the left operand to the power of the right
      operand.
  overall_explanation: Python's `**` operator is used to perform exponentiation.
  question: 'The ** operator:'
- domain: Data Aggregates
  options:
  - answer: 2 3 4 5 6 6
    correct: true
    explanation: The code shifts each element left by one position, and the last element
      remains unchanged.
  - answer: 1 2 3 4 5 6
    correct: false
    explanation: The first element gets replaced by the second, and so forth, modifying
      the list.
  - answer: 1 1 2 3 4 5
    correct: false
    explanation: The shift operation does not duplicate the first element.
  - answer: 2 3 4 5 6 1
    correct: false
    explanation: The last element remains unchanged; it does not wrap around.
  overall_explanation: The loop shifts elements left by one position, leaving the
    last element unchanged.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = [1, 2, 3, 4, 5, 6]\nfor i in range(1, 6):\n    data[i - 1] = data[i]\nfor\
    \ i in range(0, 6):\n    print(data[i], end=' ')\n```"
- domain: Operators
  options:
  - answer: multiplication precedes addition
    correct: true
    explanation: Multiplication has a higher precedence than addition in Python.
  - answer: neither statement can be evaluated
    correct: false
    explanation: Python operator precedence is well defined.
  - answer: addition precedes multiplication
    correct: false
    explanation: Addition has lower precedence than multiplication.
  overall_explanation: Python follows standard mathematical precedence where multiplication
    comes before addition.
  question: Only one of the following statements is true - which one?
- domain: Error Handling
  options:
  - answer: Bad input...
    correct: false
    explanation: The error occurs because `value` is a string, causing a `TypeError`,
      not a `ValueError`.
  - answer: Very very bad input...
    correct: true
    explanation: The `TypeError` occurs when attempting to divide a string by itself.
  - answer: Booo!
    correct: false
    explanation: A `TypeError` is explicitly handled, so the generic except block
      is not executed.
  - answer: Very bad input...
    correct: false
    explanation: ZeroDivisionError does not occur in this case.
  overall_explanation: The division operation fails because `input()` returns a string,
    causing a `TypeError`.
  question: "What is the output of the following code?\n\n```python\ntry:\n    value\
    \ = input(\"Enter a value: \")\n    print(value/value)\nexcept ValueError:\n \
    \   print(\"Bad input...\")\nexcept ZeroDivisionError:\n    print(\"Very bad input...\"\
    )\nexcept TypeError:\n    print(\"Very very bad input...\")\nexcept:\n    print(\"\
    Booo!\")\n```"
- domain: Operators
  options:
  - answer: Concatenation
    correct: true
    explanation: The += operator, when applied to strings, appends the right operand
      to the left operand, effectively concatenating them.
  - answer: Multiplication
    correct: false
    explanation: Multiplication for strings is performed using the * operator, not
      +=.
  - answer: Subtraction
    correct: false
    explanation: Strings do not support subtraction in Python.
  overall_explanation: The += operator concatenates strings by appending the right
    operand to the left operand.
  question: 'The += operator, when applied to strings, performs:'
- domain: Operators
  options:
  - answer: '7.0'
    correct: false
    explanation: The correct result of the calculation is 8.0.
  - answer: '8.0'
    correct: true
    explanation: Operator precedence ensures the operations evaluate to 8.0.
  - answer: '8'
    correct: false
    explanation: The result is a float due to the division operation.
  - answer: '9.0'
    correct: false
    explanation: The correct result of the calculation is 8.0.
  overall_explanation: Python follows operator precedence rules, leading to an output
    of 8.0.
  question: 'What is the expected output of the following code?


    ```python

    x = 9

    y = 12

    result = x // 2 * 2 / 2 + y % 2 ** 3

    print(result)

    ```'
- domain: Basics
  options:
  - answer: Guido van Rossum named it to honor Python of Catana, a dramatic poet of
      the time of Alexander the Great
    correct: false
    explanation: Python is not named after an ancient poet.
  - answer: Guido van Rossum named it after the Pythonidae - a family of large, nonvenomous
      snakes
    correct: false
    explanation: While Python is associated with snakes, its name originates from
      a comedy show.
  - answer: Guido van Rossum named it to honor Monty Python's Flying Circus, a BBC
      comedy series popular in the 1970s
    correct: true
    explanation: Guido van Rossum named Python after Monty Pythonâ€™s Flying Circus.
  overall_explanation: Python was named after a British comedy series, not the snake.
  question: How did Python, the programming language, get its name?
- domain: Functions
  options:
  - answer: 'fun fun(a, b=0):'
    correct: false
    explanation: The function definition is missing the `def` keyword.
  - answer: 'def fun(a=b=0):'
    correct: false
    explanation: This syntax is invalid; each parameter must be assigned separately.
  - answer: 'fun fun(a=0, b):'
    correct: false
    explanation: Parameters with default values must be at the end of the parameter
      list.
  - answer: 'def fun(a=0, b=0):'
    correct: true
    explanation: This correctly defines a function with two parameters, both having
      default values.
  overall_explanation: Python requires parameters with default values to be placed
    at the end.
  question: Which of the following lines properly starts a function using two parameters,
    both with zeroed default values?
- domain: Control Flow
  options:
  - answer: '10221'
    correct: false
    explanation: The expected calculation results in 11121, not 10221.
  - answer: '11121'
    correct: true
    explanation: Each type in the list contributes to the score based on the defined
      conditions.
  - answer: '10212'
    correct: false
    explanation: The calculation results in 11121, not 10212.
  - answer: '11112'
    correct: false
    explanation: The calculation results in 11121, not 11112.
  - answer: '21102'
    correct: false
    explanation: The calculation results in 11121, not 21102.
  overall_explanation: Each element's type determines how many points get added.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = [1, {}, (2,), (), {3}, [4, 5]]\npoints = 0\n\nfor i in range(len(data)):\n\
    \    if type(data[i]) == list:\n        points += 1\n    elif type(data[i]) ==\
    \ tuple:\n        points += 10\n    elif type(data[i]) == set:\n        points\
    \ += 100\n    elif type(data[i]) == dict:\n        points += 1000\n    else:\n\
    \        points += 10000\n\nprint(points)\n```"
- domain: Operators
  options:
  - answer: '64'
    correct: false
    explanation: Exponentiation is evaluated from right to left, making the final
      result 512.
  - answer: '128.0'
    correct: false
    explanation: The correct result is 512, not 128.0.
  - answer: '16.0'
    correct: false
    explanation: The correct result is 512, not 16.
  - answer: '16'
    correct: false
    explanation: The correct result is 512, not 16.
  - answer: The code is erroneous.
    correct: false
    explanation: The code executes correctly without errors.
  - answer: '512'
    correct: true
    explanation: Exponentiation is evaluated from right to left, making the final
      result 512.
  overall_explanation: Exponentiation in Python is right-associative.
  question: 'What is the expected output of the following code?


    ```python

    print(2 ** 3 ** 2 ** 1)

    ```'
- domain: Data Aggregates
  options:
  - answer: (2)
    correct: false
    explanation: The result is an integer, not a tuple.
  - answer: (2,)
    correct: false
    explanation: The tuple is sliced and accessed, but the final result is an integer.
  - answer: The code is erroneous.
    correct: false
    explanation: The code executes correctly.
  - answer: '2'
    correct: true
    explanation: The slice produces (2,4), and then the first element (2) is assigned.
  overall_explanation: Tuple slicing extracts a new tuple, and indexing selects an
    element.
  question: 'What is the expected output of the following code?


    ```python

    data = (1, 2, 4, 8)

    data = data[1:-1]

    data = data[0]

    print(data)

    ```'
- domain: Basics
  options:
  - answer: __cache__
    correct: false
    explanation: The correct folder is '__pycache__'.
  - answer: __pycache__
    correct: true
    explanation: Python stores compiled bytecode files in the '__pycache__' folder.
  - answer: __pycfiles__
    correct: false
    explanation: The correct folder is '__pycache__'.
  - answer: __pyc__
    correct: false
    explanation: The correct folder is '__pycache__'.
  overall_explanation: Python caches compiled files in '__pycache__'.
  question: 'The folder created by Python used to store pyc files is named:'
- domain: Operators
  options:
  - answer: in random order
    correct: false
    explanation: Python follows specific precedence rules, so it does not evaluate
      expressions randomly.
  - answer: from right to left
    correct: true
    explanation: Exponentiation in Python follows right-sided binding, meaning it
      evaluates from right to left.
  - answer: from left to right
    correct: false
    explanation: Exponentiation is right-associative, meaning it evaluates from right
      to left.
  overall_explanation: Python evaluates exponentiation expressions from right to left.
  question: 'Right-sided binding means that the following expression


    ```python

    1 ** 2 ** 3

    ```

    will be evaluated:'
- domain: 04 - Data Aggregates
  options:
  - answer: '[7, 3, 23, 42]'
    correct: false
    explanation: This choice is incorrect because it does not consider the modifications
      made to the list 'w' through the variables 'y' and 'z'.
  - answer: '[10, 20, 23, 42]'
    correct: false
    explanation: This choice is incorrect because it combines the changes made to
      both 'y' and 'z' but does not consider the original values.
  - answer: '[7, 20, 23, 42]'
    correct: true
    explanation: The expected output includes the modifications made through both
      'y' and 'z', resulting in [7, 20, 23, 42].
  - answer: '[10, 20, 42]'
    correct: false
    explanation: This choice is incorrect because it only considers the changes made
      to the list 'y' and does not account for modifications made through 'z'.
  overall_explanation: The two list slicings create new lists, while assigning a list
    creates a reference to the same object. Therefore, 'y' does not affect 'w', but
    'z' does.
  question: "What is the expected output of the following code?\n\n    w = [7, 3,\
    \ 23, 42]\n    x = w[1:]\n    y = w[1:]\n    z = w\n    y[0] = 10\n    z[1] =\
    \ 20\n    print(w)"
- domain: 06 - Functions
  options:
  - answer: The order of arguments passed does not matter in positional argument passing.
    correct: false
    explanation: In positional argument passing, the order of arguments passed does
      matter.
  - answer: Keyword arguments cannot be followed by positional arguments.
    correct: true
    explanation: Once a keyword argument is used, all subsequent arguments must also
      be passed as keyword arguments.
  - answer: You cannot use a mix of positional and keyword argument passing.
    correct: false
    explanation: In Python, you can use a mix of positional and keyword arguments
      as long as positional arguments come first.
  - answer: The order of arguments passed does matter in keyword argument passing.
    correct: false
    explanation: In keyword argument passing, arguments are matched based on their
      names, so order does not matter.
  overall_explanation: Python allows mixing positional and keyword arguments, but
    keyword arguments must come after positional ones.
  question: Select the true statement about function arguments.
- domain: 03 - Operators
  options:
  - answer: Performs duplicated multiplication.
    correct: false
    explanation: The ** operator does not perform duplicated multiplication; it is
      used for exponentiation.
  - answer: Performs exponentiation.
    correct: true
    explanation: The ** operator in Python is used to raise a number to the power
      of another number.
  - answer: Performs floating-point multiplication.
    correct: false
    explanation: The ** operator does not perform floating-point multiplication; it
      is strictly for exponentiation.
  - answer: Does not exist.
    correct: false
    explanation: The ** operator exists and is a built-in Python operator for exponentiation.
  overall_explanation: The ** operator is known as the exponentiation operator and
    is used to raise numbers to a power.
  question: What is the function of the ** operator in Python?
- domain: 06 - Functions
  options:
  - answer: '5'
    correct: true
    explanation: Lists are mutable, so appending an element inside the function modifies
      the original list.
  - answer: '2'
    correct: false
    explanation: This choice is incorrect because the function modifies the original
      list by adding an element to it.
  - answer: '4'
    correct: false
    explanation: This choice is incorrect because the function modifies the original
      list by adding an element to it.
  - answer: The code is erroneous.
    correct: false
    explanation: The code is not erroneous; it correctly modifies the list inside
      the function.
  overall_explanation: In Python, lists are mutable, meaning changes inside a function
    persist outside of it.
  question: "What is the expected output of the following code?\n\n    def func(item):\n\
    \        item += [1]\n\n    data = [1, 2, 3, 4]\n    func(data)\n    print(len(data))"
- domain: 04 - Data Aggregates
  options:
  - answer: '0'
    correct: true
    explanation: Multiplying any number by zero results in zero, making the final
      output 0.
  - answer: '1'
    correct: false
    explanation: Since the loop multiplies 'x' by each element, including 0, the result
      will not remain 1.
  - answer: '6'
    correct: false
    explanation: This choice is incorrect because the presence of 0 in the list ensures
      that the final value will be 0.
  overall_explanation: The for loop multiplies each element in the list by 'x', and
    since the list contains 0, the final result is 0.
  question: "What is the expected output of the following code?\n\n    my_list = [0,\
    \ 1, 2, 3]\n    x = 1\n    for elem in my_list:\n        x *= elem\n    print(x)"
- domain: 02 - Data Types
  options:
  - answer: 'print(data.join(''

      ''))'
    correct: false
    explanation: Lists do not have a 'join' method; 'join' is a string method.
  - answer: 'print(data.concatenate(''

      ''))'
    correct: false
    explanation: There is no 'concatenate' method for lists in Python.
  - answer: 'print(''

      ''.join(data))'
    correct: true
    explanation: The 'join' method is used with a string separator to concatenate
      list elements with a newline character.
  overall_explanation: 'Using ''

    ''.join(data) concatenates the elements with newline characters, effectively printing
    each name on a new line.'
  question: "Which statement correctly prints each name in the list on a new line?\n\
    \n    data = ['Peter', 'Paul', 'Mary', 'Jane']"
- domain: Basics
  options:
  - answer: pi
    correct: false
    explanation: The file extension '.pi' is not a standard Python file extension.
      Python files should have the '.py' extension to be recognized and executed as
      Python code.
  - answer: p
    correct: false
    explanation: The file extension '.p' is not a standard Python file extension.
      Python files should have the '.py' extension to be recognized and executed as
      Python code.
  - answer: py
    correct: true
    explanation: The file extension '.py' is the standard file extension for Python
      files. It is used to indicate that the file contains Python code and should
      be interpreted by the Python interpreter.
  overall_explanation: Python files use the '.py' extension to indicate that they
    contain Python source code. Other extensions like '.pi' and '.p' are not valid
    for Python scripts.
  question: Which one of the following is an example of a Python file extension?
- domain: Control Flow
  options:
  - answer: two
    correct: false
    explanation: The list comprehension generates a list with elements from -1 up
      to (but not including) 2. Since the range includes -1, 0, and 1, the resulting
      list will contain three elements, not just two.
  - answer: three
    correct: true
    explanation: The list comprehension generates a list with elements from -1 up
      to (but not including) 2. Since the range includes -1, 0, and 1, the resulting
      list will contain three elements.
  - answer: one
    correct: false
    explanation: The list comprehension generates a list with elements from -1 up
      to (but not including) 2. Since the range includes -1, 0, and 1, the resulting
      list will contain three elements, not just one.
  - answer: zero
    correct: false
    explanation: The list comprehension generates a list with elements from -1 up
      to (but not including) 2. It includes -1, 0, and 1, so the resulting list will
      not be empty and will contain three elements, not zero.
  - answer: four
    correct: false
    explanation: The list comprehension generates a list with elements from -1 up
      to (but not including) 2. Since the range includes -1, 0, and 1, the resulting
      list will contain three elements, not four.
  overall_explanation: The `range(-1, 2)` function produces values -1, 0, and 1, which
    results in a list of three elements. The end value 2 is exclusive, so it is not
    included.
  question: 'How many elements will the following list contain?


    ```python

    data = [i for i in range(-1, 2)]

    ```'
- domain: Data Aggregates
  options:
  - answer: nums is longer than vals
    correct: false
    explanation: As `vals` is a reference to the list `nums`, appending a value to
      `vals` will also modify the original list `nums`. Therefore, both `nums` and
      `vals` will have the same length, and `nums` will not be longer than `vals`.
  - answer: vals is longer than nums
    correct: false
    explanation: Since `vals` is a reference to the list `nums`, appending a value
      to `vals` will also modify the original list `nums`. As a result, both `nums`
      and `vals` will have the same length, and `vals` will not be longer than `nums`.
  - answer: nums and vals are of the same length
    correct: true
    explanation: When the value 1 is appended to the list `vals`, it is also appended
      to the list `nums` because `vals` is a reference to the same list as `nums`.
      Therefore, both `nums` and `vals` will have the same length after appending
      1.
  overall_explanation: Lists in Python are mutable and stored by reference. Assigning
    `vals = nums` does not create a new list, but instead makes `vals` point to the
    same list as `nums`. Any modification to `vals` will also reflect in `nums`.
  question: 'Take a look at the snippet and choose one of the following statements
    which is true:


    ```python

    nums = []

    vals = nums

    vals.append(1)

    ```'
- domain: Control Flow
  options:
  - answer: a < b
    correct: false
    explanation: The expression `a < b` checks if `a` is less than `b`, but in this
      case, `a` is greater than `b`.
  - answer: a == b
    correct: false
    explanation: The values of `a` and `b` are not equal, so this condition would
      evaluate to False.
  - answer: a > b
    correct: true
    explanation: The value of `a` is calculated as `7 + 3 * 4 = 19`, and `b` is `7
      + 3 / 1 = 10`. Since `a` is greater than `b`, the condition evaluates to True.
  - answer: a <= b
    correct: false
    explanation: Since `a` is greater than `b`, this condition would be False, and
      'FALSE' would be printed.
  overall_explanation: 'Operator precedence applies here: multiplication happens before
    addition, affecting `a` and `b`''s values.'
  question: "What would you insert instead of ??? so that the program prints TRUE\
    \ to the monitor?\n\n```python\nw = 7\nx = 3\ny = 4\nz = True\na = w + x * y\n\
    b = w + x / z\n \nif ???:\n    print('TRUE')\nelse:\n    print('FALSE')\n```"
- domain: Functions
  options:
  - answer: It will print 6
    correct: false
    explanation: The final value of `x` will be 4, so `a(x)` will return 8, not 6.
  - answer: Cause a runtime exception on Line 8
    correct: false
    explanation: There is no runtime error; the function executes correctly.
  - answer: Cause a runtime exception on Line 9
    correct: false
    explanation: The function call is valid and executes properly.
  - answer: Print 8
    correct: true
    explanation: '`x = 2 + a(x)` calculates `2 + (2 * 1) = 4`, so `a(x)` prints `2
      * 4 = 8`.'
  overall_explanation: The function takes an argument and returns twice its value.
    The new value of `x` is computed before passing it to `a()`.
  question: "What is the expected behavior of the following snippet?\n\n```python\n\
    x = 1\n \ndef a(x):\n    return 2 * x\n \nx = 2 + a(x)  # Line 8\nprint(a(x))\
    \  # Line 9\n```"
- domain: Control Flow
  options:
  - answer: '3'
    correct: true
    explanation: The code initializes `res` with `42` and iterates over all elements,
      updating `res` to the smallest value, which is `3`.
  - answer: The code is erroneous.
    correct: false
    explanation: The code executes correctly and does not raise any errors.
  - answer: '42'
    correct: false
    explanation: Although `42` is the first element, the loop updates `res` to the
      smallest value found.
  - answer: '13'
    correct: false
    explanation: The smallest value in the list is `3`, not `13`.
  overall_explanation: The nested loop iterates over the matrix and updates `res`
    whenever a smaller value is found.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = [[42, 17, 23, 13], [11, 9, 3, 7]]\nres = data[0][0]\nfor da in data:\n   \
    \ for d in da:\n        if res > d:\n            res = d\nprint(res)\n```"
- domain: Data Aggregates
  options:
  - answer: d = dict(t)
    correct: true
    explanation: Using `dict()` with a tuple of key-value pairs properly converts
      it into a dictionary.
  - answer: d.dict(t)
    correct: false
    explanation: This syntax is invalid; `dict()` is not a method of `d`.
  - answer: d = t(dict)
    correct: false
    explanation: This syntax is incorrect and does not create a dictionary.
  - answer: t >> d.dict
    correct: false
    explanation: This is an invalid way to create a dictionary from a tuple.
  overall_explanation: The `dict()` constructor properly transforms a tuple of pairs
    into a dictionary.
  question: 'Which of the following snippets correctly converts the tuple `t` to a
    dictionary named `d`?


    ```python

    t = ((''A'', 1), (''B'', 2), (''C'', 3))

    # insert code here

    print(d)

    ```'
- domain: Data Aggregates
  options:
  - answer: 42 23 7
    correct: false
    explanation: Sorting applies to dictionary keys (`'x'`, `'y'`, `'z'`), not their
      values.
  - answer: 7 42 23
    correct: true
    explanation: The dictionary keys are sorted alphabetically, leading to values
      being printed in order of `x`, `y`, and `z`.
  - answer: 7 23 42
    correct: false
    explanation: The sorting occurs based on keys, not values.
  overall_explanation: The `sorted()` function sorts the dictionary keys alphabetically
    before accessing their values.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = {'z': 23, 'x': 7, 'y': 42}\nfor _ in sorted(data):\n    print(data[_], end='\
    \ ')\n```"
- domain: Control Flow
  options:
  - answer: Misnamed variable(s)
    correct: false
    explanation: The variables `room` and `rooms` are correctly named; the error is
      due to a type mismatch.
  - answer: Mismatched data type(s)
    correct: true
    explanation: '`input()` returns a string, but the dictionary keys are integers,
      causing the lookup to fail.'
  - answer: None of the above.
    correct: false
    explanation: The issue is due to type mismatching, which prevents the dictionary
      lookup from succeeding.
  - answer: Invalid Syntax
    correct: false
    explanation: The syntax is correct, but the data types do not match.
  overall_explanation: Dictionary keys are integers, but `input()` returns a string,
    leading to a failed lookup.
  question: "What is the expected output of the following code?\n\n```python\nroom\
    \ = input('Enter the room number: ')\nrooms = {101: 'Gathering Place', 102: 'Meeting\
    \ Room'}\nif not room in rooms:\n    print('The room doesn\\'t exist.')\nelse:\n\
    \    print('The room name is: ' + rooms[room])\n```"
- domain: Operators
  options:
  - answer: '2'
    correct: true
    explanation: The modulus operation `7 % 2` results in `1`, and adding `1` gives
      `2`.
  - answer: '1'
    correct: false
    explanation: The value of `y` is incremented, so the final result is `2`.
  - answer: '3'
    correct: false
    explanation: The correct result is `2`, not `3`.
  - answer: '5'
    correct: false
    explanation: The final result is `2`, not `5`.
  overall_explanation: The modulus operator returns the remainder of division, and
    `+=` increments the result.
  question: 'What is the result of the following code?


    ```python

    x = 7

    y = x % 2

    y += 1

    print(y)

    ```'
- domain: Functions
  options:
  - answer: '[''JA'', ''ST'']'
    correct: false
    explanation: The slicing starts at index `2`, which includes `Mary`, `Jane`, and
      `Steve`, so two elements are missing.
  - answer: '[''JAN'', ''STE'']'
    correct: false
    explanation: This choice includes only the last two names, but the slicing starts
      at `Mary`, so `MAR` should also be included.
  - answer: '[''MAR'', ''JAN'', ''STE'']'
    correct: true
    explanation: The function slices the list from `Mary` onward, then extracts the
      first three letters from each name and converts them to uppercase.
  - answer: '[''MA'', ''JA'', ''ST'']'
    correct: false
    explanation: Each name slice takes the first three letters, not two.
  overall_explanation: The function `get_names()` slices the list from `Mary` onwards,
    and `update_names()` converts the first three letters of each name to uppercase.
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ get_names():\n    names = ['Peter', 'Paul', 'Mary', 'Jane', 'Steve']\n    return\
    \ names[2:]\n\n\ndef update_names(names):\n    res = []\n    for name in names:\n\
    \        res.append(name[:3].upper())\n    return res\n\nprint(update_names(get_names()))\n\
    ```"
- domain: Data Aggregates
  options:
  - answer: '[10, 2, 20, 4, 30, 6, 40, 8, 50, 60]'
    correct: false
    explanation: The code is erroneous because the number of replacement values does
      not match the number of elements selected by slicing.
  - answer: '[1, 2, 10, 20, 30, 40, 50, 60]'
    correct: false
    explanation: This does not match the behavior of the slicing operation.
  - answer: '[1, 10, 3, 20, 5, 30, 7, 40, 9, 50, 60]'
    correct: false
    explanation: The list update does not work because of mismatched lengths.
  - answer: The code is erroneous.
    correct: true
    explanation: The number of elements assigned does not match the number of selected
      indices, causing an error.
  overall_explanation: List slicing assigns values to selected indices, but the number
    of elements must match the number of selected positions.
  question: 'What is the expected output of the following code?


    ```python

    x = [1, 2, 3, 4, 5, 6, 7, 8, 9]

    x[::2] = 10, 20, 30, 40, 50, 60

    print(x)

    ```'
- domain: Error Handling
  options:
  - answer: '`except (TypeError, ValueError, ZeroDivisionError):`'
    correct: true
    explanation: Grouping exceptions inside parentheses allows multiple exceptions
      to be caught.
  - answer: '`except: (TypeError, ValueError, ZeroDivisionError)`'
    correct: false
    explanation: Incorrect syntax; exceptions must be inside parentheses following
      `except`.
  - answer: '`except TypeError, ValueError, ZeroDivisionError:`'
    correct: false
    explanation: Multiple exceptions must be enclosed in parentheses.
  - answer: '`except: TypeError, ValueError, ZeroDivisionError`'
    correct: false
    explanation: Incorrect syntax; the list of exceptions must be inside parentheses.
  overall_explanation: Python requires multiple exceptions to be grouped within parentheses
    in a single `except` clause.
  question: Which of the following is the correct way to handle multiple exceptions
    in a single `except` clause?
- domain: Functions
  options:
  - answer: It will output 4
    correct: false
    explanation: The function expects two arguments, but only one is provided, leading
      to an error.
  - answer: It will return None
    correct: false
    explanation: The function is defined with two parameters but called with only
      one argument, causing an error.
  - answer: It is erroneous
    correct: true
    explanation: The function call is missing the second required argument, which
      results in a `TypeError`.
  - answer: It will output 2
    correct: false
    explanation: The function would calculate `2**2` if properly called, but the missing
      argument makes it invalid.
  overall_explanation: Python functions must be called with the correct number of
    arguments unless default values are provided.
  question: "What will be the output of the following code?\n\n```python\ndef func(a,\
    \ b):\n    return a ** a\n\nprint(func(2))\n```"
- domain: Control Flow
  options:
  - answer: Misnamed variable(s)
    correct: false
    explanation: All variables are correctly named. The issue is related to data types.
  - answer: Mismatched data type(s)
    correct: true
    explanation: The `input()` function returns a string, while the dictionary keys
      are integers. This causes a key lookup failure.
  - answer: None of the above
    correct: false
    explanation: The issue is a type mismatch between the input and the dictionary
      keys.
  - answer: Invalid Syntax
    correct: false
    explanation: The syntax is valid, but a data type mismatch prevents the dictionary
      lookup from succeeding.
  overall_explanation: The `input()` function always returns a string, which must
    be converted to an integer before being used as a dictionary key.
  question: "Consider the following code snippet:\n\n```python\nroom = input('Enter\
    \ the room number: ')\nrooms = {101: 'Gathering Place', 102: 'Meeting Room'}\n\
    if not room in rooms:\n    print('The room doesn\\'t exist.')\nelse:\n    print('The\
    \ room name is: ' + rooms[room])\n```"
- domain: Data Aggregates
  options:
  - answer: '`{''A'': 1, ''B'': 2, ''C'': 3}`'
    correct: true
    explanation: The `dict()` function correctly converts a tuple of key-value pairs
      into a dictionary.
  - answer: '`d.dict(t)`'
    correct: false
    explanation: This is incorrect syntax; `dict()` should be used as a constructor.
  - answer: '`d = t(dict)`'
    correct: false
    explanation: This is an invalid way to convert a tuple into a dictionary.
  - answer: '`t >> d.dict`'
    correct: false
    explanation: This is incorrect syntax; the `dict()` function must be used explicitly.
  overall_explanation: The `dict()` function takes an iterable of key-value pairs
    and converts it into a dictionary.
  question: 'What is the expected output of the following code?


    ```python

    t = ((''A'', 1), (''B'', 2), (''C'', 3))

    d = dict(t)

    print(d)

    ```'
- domain: Basics
  options:
  - answer: You cannot use keywords as variable names in Python
    correct: true
    explanation: Python keywords have predefined meanings and cannot be used as variable
      names.
  - answer: You can use keywords as variable names in Python
    correct: false
    explanation: Python does not allow using keywords as variable names.
  - answer: You can use keywords as function names in Python
    correct: false
    explanation: Python keywords cannot be used as function names.
  - answer: You cannot use keywords as function names in Python
    correct: true
    explanation: Python reserves keywords for specific functionalities, preventing
      their use as function names.
  overall_explanation: Keywords in Python have predefined meanings and cannot be used
    as variable or function names.
  question: Which of the following statements about Python keywords is correct?
- domain: Basics
  options:
  - answer: A high-level programming language consisting of instruction lists that
      humans can read and understand.
    correct: false
    explanation: Machine code is not high-level and is not meant to be human-readable.
  - answer: A low-level programming language consisting of binary digits/bit that
      the computer reads and understands.
    correct: true
    explanation: Machine code consists of binary instructions that the CPU executes
      directly.
  - answer: A low-level programming language consisting of hexadecimal digits that
      make up high-level language instructions.
    correct: false
    explanation: Machine code is primarily binary, though hexadecimal is used for
      human readability.
  - answer: A medium-level programming language consisting of assembly code designed
      for the computer processor.
    correct: false
    explanation: Assembly is a low-level representation of machine code but is not
      machine code itself.
  overall_explanation: Machine code is the lowest-level representation of a program,
    consisting of binary instructions executed directly by the CPU.
  question: What is machine code?
- domain: Data Aggregates
  options:
  - answer: '6'
    correct: true
    explanation: The expected output is 6 because the dictionary treats 1 and 1.0
      as the same key, overwriting the previous value.
  - answer: '3'
    correct: false
    explanation: The output is not 3; the dictionary keys are 1, '1', and 1.0, with
      values of 4, 2, and 4 respectively.
  - answer: The code is erroneous.
    correct: false
    explanation: The code is valid and executes correctly.
  - answer: '7'
    correct: false
    explanation: The sum is not 7, as the keys are iterated and their values summed
      up, resulting in 6.
  overall_explanation: Dictionary keys 1 and 1.0 are considered the same, leading
    to overwriting of values.
  question: "What is the expected output of the following code?\n\n```python\ndata\
    \ = {}\ndata[1] = 1\ndata['1'] = 2\ndata[1.0] = 4\n \nres = 0\nfor d in data:\n\
    \    res += data[d]\n \nprint(res)\n```"
- domain: Data Aggregates
  options:
  - answer: '[1, 2, 3, 1, 2, 3]'
    correct: false
    explanation: The insert operation always shifts elements, altering the list structure.
  - answer: '[1, 1, 1, 1, 2, 3]'
    correct: true
    explanation: The insert function shifts elements, repeatedly inserting at index
      1.
  - answer: '[3, 2, 1, 1, 2, 3]'
    correct: false
    explanation: The insert operation does not reverse the list.
  - answer: '[1, 2, 3, 3, 2, 1]'
    correct: false
    explanation: Insertion shifts elements but does not result in this pattern.
  overall_explanation: The loop inserts each element at index 1, causing repeated
    insertions and shifts.
  question: "What is the output of the following snippet?\n\n```python\nl1 = [1, 2,\
    \ 3]\n \nfor v in range(len(l1)):\n    l1.insert(1, l1[v])\n \nprint(l1)\n```"
- domain: Data Aggregates
  options:
  - answer: The code is erroneous.
    correct: true
    explanation: Dictionaries cannot use other dictionaries as keys.
  - answer: '3'
    correct: false
    explanation: The error occurs before any valid length computation.
  - answer: '4'
    correct: false
    explanation: The length cannot be computed due to a key error.
  - answer: '2'
    correct: false
    explanation: The dictionary key issue prevents length calculation.
  overall_explanation: Dictionaries cannot have other dictionaries as keys due to
    immutability constraints.
  question: "What is the expected output of the following code?\n\n```python\nbox\
    \ = {}\njars = {}\ncrates = {}\n \nbox['biscuit'] = 1\nbox['cake'] = 3\n \njars['jam']\
    \ = 4\n \ncrates['box'] = box\ncrates['jars'] = jars\n \nprint(len(crates[box]))\n\
    ```"
- domain: Data Types
  options:
  - answer: r
    correct: false
    explanation: Adding 3 to the ASCII value of 'p' results in 's', not 'r'.
  - answer: s
    correct: true
    explanation: The `ord()` function retrieves ASCII value, `chr()` converts it back.
      'p' + 3 results in 's'.
  - answer: t
    correct: false
    explanation: The ASCII value of 'p' plus 3 is 's', not 't'.
  - answer: q
    correct: false
    explanation: The ASCII conversion results in 's', not 'q'.
  overall_explanation: '`ord()` converts a character to its integer ASCII representation,
    and `chr()` converts it back.'
  question: 'What is the expected output of the following code?


    ```python

    print(chr(ord(''p'') + 3))

    ```'
- domain: Functions
  options:
  - answer: Quotation marks
    correct: false
    explanation: Quotation marks are used for strings, not function parameters.
  - answer: Parentheses
    correct: true
    explanation: Function parameters are enclosed in parentheses.
  - answer: Brackets
    correct: false
    explanation: Brackets are used for indexing, not function parameters.
  - answer: Curly braces
    correct: false
    explanation: Curly braces are used for sets and dictionaries, not function parameters.
  overall_explanation: Function parameters are always enclosed in parentheses when
    defining and calling functions.
  question: Which of the following enclose the input parameters or arguments of a
    function?
- domain: Functions
  options:
  - answer: '5'
    correct: false
    explanation: The function increments the value by 1, resulting in 4, not 5.
  - answer: '4'
    correct: true
    explanation: The function receives `3`, increments it, and returns `4`.
  - answer: '3'
    correct: false
    explanation: The function adds `1`, returning `4`, not `3`.
  - answer: The code is erroneous.
    correct: false
    explanation: The code executes correctly without errors.
  overall_explanation: Function parameters are passed by value, and the returned result
    is stored in `x`.
  question: "What will be the output of the following code?\n\n```python\ndef fun(x):\n\
    \    x += 1\n    return x\n\n\nx = 2\nx = fun(x + 1)\nprint(x)\n```"
- domain: 05 - Control Flow
  options:
  - answer: No output
    correct: false
    explanation: The loop iterates over the numbers 1, 2, and 3. Since only 2 is even,
      the print statement executes once, outputting '*'.
  - answer: '*'
    correct: true
    explanation: The condition `i % 2 == 0` is true only for `i = 2`, so one asterisk
      is printed.
  - answer: '**'
    correct: false
    explanation: Only one iteration (when `i = 2`) meets the condition, so only one
      '*' is printed, not two.
  - answer: '***'
    correct: false
    explanation: The loop iterates three times, but only one meets the condition (`i
      = 2`), so the output is not three asterisks.
  overall_explanation: "The loop runs three times with values 1, 2, and 3. The condition\
    \ `i % 2 == 0` is only met when `i = 2`, resulting in a single '*'. \n"
  question: "What is the expected output of the following code?\n\n```python\nfor\
    \ i in range(1, 4):\n    if i % 2 == 0:\n        print('*')\n```\n"
- domain: 03 - Operators
  options:
  - answer: '11'
    correct: true
    explanation: The `+=` operator adds the result of `2 * 3` (which is 6) to `x`,
      making `x = 5 + 6 = 11`.
  - answer: '10'
    correct: false
    explanation: This would be correct if the multiplication was ignored, but `x +=
      2 * 3` evaluates as `x = 5 + 6`.
  - answer: '8'
    correct: false
    explanation: This would be correct if the multiplication was `2 + 3` instead of
      `2 * 3`, but the multiplication takes precedence.
  - answer: '5'
    correct: false
    explanation: The value of `x` is modified by the `+=` operator, so it does not
      remain 5.
  overall_explanation: 'The multiplication `2 * 3` is evaluated first due to operator
    precedence, resulting in `6`. Then, `x += 6` adds 6 to the original value of `x`,
    making it 11.

    '
  question: 'What will be the value of `x` after executing the following code?


    ```python

    x = 5

    x += 2 * 3

    ```

    '
- domain: 04 - Data Aggregates
  options:
  - answer: '[1, 2, 3]'
    correct: false
    explanation: The `append()` method adds an element to the list, so `4` is added
      to `data`.
  - answer: '[1, 2, 3, 4]'
    correct: true
    explanation: The `append()` method adds `4` to the list, modifying it to `[1,
      2, 3, 4]`.
  - answer: '[4, 1, 2, 3]'
    correct: false
    explanation: The `append()` method adds the new element to the end, not the beginning.
  - answer: '[1, 2, 3], 4'
    correct: false
    explanation: The print statement prints the entire list as a single entity, not
      as separate values.
  overall_explanation: 'The `append()` method modifies the list by adding an element
    at the end. In this case, `4` is appended to `[1, 2, 3]`, resulting in `[1, 2,
    3, 4]`.

    '
  question: 'What will be printed by the following code?


    ```python

    data = [1, 2, 3]

    data.append(4)

    print(data)

    ```

    '
- domain: 06 - Functions
  options:
  - answer: '5'
    correct: true
    explanation: The function `func` returns the sum of `a` and `b`, which is `2 +
      3 = 5`.
  - answer: '23'
    correct: false
    explanation: This would happen if `a` and `b` were strings (`'2' + '3'`), but
      they are integers.
  - answer: None
    correct: false
    explanation: The function contains a return statement, so it does not return `None`.
  - answer: Error
    correct: false
    explanation: There are no syntax errors in the function definition or call.
  overall_explanation: 'The function `func` takes two arguments and returns their
    sum. The call `func(2, 3)` correctly computes `2 + 3`, which results in `5`.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(a, b):\n    return a + b\n\nprint(func(2, 3))\n```\n"
- domain: 01 - Basics
  options:
  - answer: true
    correct: true
    explanation: 'The variable name "True" is illegal because it is a reserved keyword
      in Python and cannot be used as an identifier for a variable.

      '
  - answer: true
    correct: false
    explanation: 'The variable name "TRUE" is a valid variable name in Python as it
      is case-sensitive and different from the reserved keyword "True".

      '
  - answer: and
    correct: true
    explanation: 'The variable name "and" is illegal because it is a reserved keyword
      in Python and cannot be used as an identifier for a variable.

      '
  - answer: true
    correct: false
    explanation: 'The variable name "true" is a valid variable name in Python as it
      is case-sensitive and different from the reserved keyword "True".

      '
  overall_explanation: 'Reserved keywords like "True" and "and" cannot be used as
    variable names in Python. Python is case-sensitive, so variations like "TRUE"
    and "true" are allowed.

    '
  question: 'Which of the following variable names are illegal? (Select two answers)

    '
- domain: 03 - Operators
  options:
  - answer: =/=
    correct: false
    explanation: 'The `=/=` operator is not a valid operator in Python for checking
      non-equality between two values. In Python, the `!=` operator is used for this
      purpose, so `=/=` is an incorrect choice.

      '
  - answer: '!='
    correct: true
    explanation: 'The `!=` operator in Python is used to check whether two values
      are not equal to each other. It is the standard way to express inequality in
      Python and is the correct choice for checking non-equality between two values.

      '
  - answer: not ==
    correct: false
    explanation: 'The `not ==` operator does not directly check for non-equality.
      Instead, it negates the equality check. The correct operator for non-equality
      is `!=`.

      '
  - answer: <>
    correct: false
    explanation: 'The `<>` operator was used in older versions of Python to check
      for inequality, but it is no longer supported in Python 3. Therefore, it is
      not valid.

      '
  overall_explanation: 'In Python, the `!=` operator is used to check inequality.
    Older operators like `<>` or unconventional combinations like `not ==` are either
    invalid or unnecessary.

    '
  question: 'An operator able to check whether two values are not equal is coded as:

    '
- domain: 03 - Operators
  options:
  - answer: (a + (b * c)) - d
    correct: true
    explanation: 'This expression is equivalent to the original expression in the
      function because it first calculates the result of the multiplication operation
      `(b * c)`, then adds the value of `a`, and finally subtracts the value of `d`.

      '
  - answer: a + ((b * c) - d)
    correct: false
    explanation: 'This expression is not equivalent because it calculates `(b * c)
      - d` first and then adds `a`, which changes the order of operations.

      '
  - answer: (a + b) * (c - d)
    correct: false
    explanation: 'This expression is incorrect because it adds `a` and `b` first,
      then multiplies the result by `(c - d)`, which changes the order of operations.

      '
  - answer: None of the above.
    correct: false
    explanation: 'The correct equivalent expression is `(a + (b * c)) - d`, so this
      choice is incorrect.

      '
  overall_explanation: 'Python follows operator precedence rules. Multiplication (`*`)
    has higher precedence than addition (`+`) or subtraction (`-`). Parentheses can
    alter the order of evaluation when used.

    '
  question: "Which of the following expressions is equivalent to the expression in\
    \ the function?\n\n```python\ndef main(a, b, c, d):\n    value = a + b * c - d\n\
    \    return value\n```\n"
- domain: 06 - Functions
  options:
  - answer: A function
    correct: false
    explanation: 'While `isalnum()` performs a function, it is not a standalone function.
      It is a method called on a string object.

      '
  - answer: A module
    correct: false
    explanation: 'The `isalnum()` method is not a module. Modules are files containing
      Python code that can be imported into other programs.

      '
  - answer: A method
    correct: true
    explanation: 'The `isalnum()` method is a built-in method in Python. It checks
      if a string contains only alphanumeric characters and is associated with string
      objects.

      '
  overall_explanation: 'In Python, methods like `isalnum()` are tied to specific objects
    (strings in this case) and are called using dot notation. Modules and functions
    are distinct entities.

    '
  question: '`isalnum()` checks if a string contains only letters and digits, and
    this is:

    '
- domain: 01 - Basics
  options:
  - answer: 1 2 2
    correct: false
    explanation: 'The code reassigns values in a way that results in `x = 1`, `y =
      1`, and `z = 2`. Therefore, the output is not `1 2 2`.

      '
  - answer: 2 1 2
    correct: false
    explanation: 'The final values of the variables are `x = 1`, `y = 1`, and `z =
      2`, so the output is not `2 1 2`.

      '
  - answer: 1 1 2
    correct: true
    explanation: 'The code reassigns the values of the variables step by step. The
      final values are `x = 1`, `y = 1`, and `z = 2`, which results in the output
      `1 1 2`.

      '
  - answer: 1 2 1
    correct: false
    explanation: 'The variables do not hold these values at the end of the code execution.
      The correct values are `x = 1`, `y = 1`, and `z = 2`.

      '
  overall_explanation: 'Python allows multiple assignments in a single line. The final
    values of variables depend on the order of assignments, which are evaluated sequentially.

    '
  question: 'What is the expected output of the following code?


    ```python

    x = 1

    y = 2

    x, y, z = x, x, y

    z, y, z = x, y, z

    print(x, y, z)

    ```

    '
- domain: 01 - Basics
  options:
  - answer: create a docstring.
    correct: false
    explanation: 'The digraph `#!` is not used to create a docstring. Docstrings are
      created using triple quotes (`''''''` or `"""`).

      '
  - answer: tell an MS Windows OS how to execute the contents of a Python file.
    correct: false
    explanation: 'The digraph `#!` is used for Unix or Unix-like operating systems,
      not for Windows. Windows uses file associations or the Python Launcher.

      '
  - answer: make a particular module entity a private one.
    correct: false
    explanation: 'The `#!` digraph does not relate to privacy in Python modules. Underscores
      (`_`) are used for this purpose.

      '
  - answer: tell a Unix or Unix-like OS how to execute the contents of a Python file.
    correct: true
    explanation: 'The digraph `#!` is known as a shebang and is used in Unix-like
      systems to specify the interpreter that should run the script.

      '
  overall_explanation: 'The `#!` shebang specifies the path to the interpreter in
    Unix-based systems, allowing the script to execute directly from the command line.

    '
  question: 'The digraph written as `#!` is used to:

    '
- domain: 06 - Functions
  options:
  - answer: 1 1
    correct: false
    explanation: 'The code will raise an `UnboundLocalError` because the variable
      `num` is being modified inside the function without being declared as global.
      The output will not be `1 1`.

      '
  - answer: 1 4
    correct: false
    explanation: 'The code will raise an `UnboundLocalError` due to the same issue.
      Python treats `num` as a local variable inside the function, and it is referenced
      before being assigned.

      '
  - answer: 4 1
    correct: false
    explanation: 'The code will raise an `UnboundLocalError`, so this output will
      not occur.

      '
  - answer: 4 4
    correct: false
    explanation: 'The code is erroneous, and an `UnboundLocalError` will prevent any
      output.

      '
  - answer: The code is erroneous.
    correct: true
    explanation: 'The code raises an `UnboundLocalError` because the variable `num`
      is treated as local inside the function and is referenced before assignment.

      '
  overall_explanation: 'To avoid an `UnboundLocalError`, you can declare `num` as
    global inside the function or modify the code to avoid conflicting with the global
    variable. Shadowing occurs when a local variable hides a variable in the outer
    scope.

    '
  question: "What is the expected output of the following code?\n\n```python\nnum\
    \ = 1\n\ndef func():\n    num = num + 3\n    print(num)\n\nfunc()\n\nprint(num)\n\
    ```\n"
- domain: 05 - Control Flow
  options:
  - answer: "```python\nfor i in range(0, 5):\n    print(str(i) * 5)\n```\n"
    correct: false
    explanation: 'This loop starts at 0, so the output will include a line of `00000`
      at the beginning, which does not match the desired pattern.

      '
  - answer: "```python\nfor i in range(1, 6):\n    print(str(i) * 5)\n```\n"
    correct: true
    explanation: 'This loop iterates from 1 to 5 (inclusive of 1 and exclusive of
      6), and prints each number as a string, repeated 5 times. This produces the
      correct pattern.

      '
  - answer: "```python\nfor i in range(1, 6):\n    print(i, i, i, i, i)\n```\n"
    correct: false
    explanation: 'This loop outputs the numbers with spaces between them, such as
      `1 1 1 1 1`. The desired pattern requires no spaces between the digits.

      '
  - answer: "```python\nfor i in range(1, 5):\n    print(str(i) * 5)\n```\n"
    correct: false
    explanation: 'This loop excludes the number `5` because the range ends at `5`
      (exclusive). As a result, it does not produce the complete desired pattern.

      '
  overall_explanation: 'To generate the exact pattern, you need to use `range(1, 6)`
    to include numbers 1 through 5, and multiply the string representation of the
    number by 5 to create repeated digits without spaces.

    '
  question: 'Which of the following for loops would output the below number pattern?


    ```

    11111

    22222

    33333

    44444

    55555

    ```

    '
- domain: 04 - Data Aggregates
  options:
  - answer: (1,2)
    correct: false
    explanation: 'The code accesses and prints specific elements from the tuples,
      not the tuples themselves. This output is incorrect.

      '
  - answer: (2,1)
    correct: false
    explanation: 'Similarly, this output is incorrect because the code accesses individual
      elements from the tuples, not the tuples themselves.

      '
  - answer: 21
    correct: true
    explanation: 'The code iterates through the dictionary keys and prints the second
      element (`[1]`) of each tuple in the order of insertion. The result is `21`.

      '
  - answer: 12
    correct: false
    explanation: 'The code prints the second element of each tuple in the order they
      were added to the dictionary, which is `21`, not `12`.

      '
  overall_explanation: 'Dictionary keys are iterated in the order they are inserted
    (Python 3.7+). Accessing `dct[x][1]` retrieves the second element of each tuple,
    resulting in the concatenated output `21`.

    '
  question: "What is the output of the following snippet?\n\n```python\ndct = {}\n\
    dct['1'] = (1, 2)\ndct['2'] = (2, 1)\n\nfor x in dct.keys():\n    print(dct[x][1],\
    \ end='')\n```\n"
- domain: 05 - Control Flow
  options:
  - answer: '1

      3

      4

      '
    correct: false
    explanation: 'The first condition prints "1", and the `elif` condition prints
      "3". The `else` block will not execute as the `elif` condition is true, so "4"
      is not printed.

      '
  - answer: '1

      4

      '
    correct: false
    explanation: 'The first condition prints "1", but the `elif` condition is true
      and prints "3", so the `else` block is skipped.

      '
  - answer: 1
    correct: false
    explanation: 'The first condition prints "1", but the code also evaluates the
      `elif` condition and prints "3".

      '
  - answer: '1

      3

      '
    correct: true
    explanation: 'The first condition prints "1" because `x > 0` is true. The `elif`
      condition `x >= 1` is also true, so "3" is printed. The `else` block does not
      execute.

      '
  overall_explanation: 'The `if`, `elif`, and `else` blocks are evaluated sequentially.
    The `or` condition in the first block evaluates to true, and the `elif` condition
    also evaluates to true. Only the first matching branch of `elif` or `else` is
    executed.

    '
  question: "What is the expected output of the following code?\n\n```python\nx =\
    \ 1\n\nif x > 0 or x < 1:\n    print(\"1\")\nif x > 1:\n    print(\"2\")\nelif\
    \ x >= 1:\n    print(\"3\")\nelse:\n    print(\"4\")\n```\n"
- domain: 05 - Control Flow
  options:
  - answer: The code is erroneous.
    correct: false
    explanation: 'The code is valid and executes without errors. It correctly defines
      and calls the function `func`.

      '
  - answer: 2
    correct: false
    explanation: 'The inner call `func(1)` evaluates to `1` (since `1 % 2 != 0` is
      true). The outer call `func(1)` also evaluates to `1`. Thus, the output is not
      `2`.

      '
  - answer: 1
    correct: true
    explanation: 'The inner `func(1)` evaluates to `1` because `1 % 2 != 0` is true.
      The outer `func(1)` also evaluates to `1`. Therefore, the output is `1`.

      '
  - answer: None
    correct: false
    explanation: 'The function returns an integer (`1` or `2`), not `None`. The output
      is `1`.

      '
  overall_explanation: 'The function uses a conditional expression to return `1` for
    odd inputs and `2` for even inputs. The nested call results in `func(func(1))`
    resolving to `func(1)`, which returns `1`.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(x):\n    return 1 if x % 2 != 0 else 2\n\nprint(func(func(1)))\n```\n"
- domain: 01 - Basics
  options:
  - answer: It's a programming language that is a superset of the C language, designed
      to produce Python-like performance with code written in C.
    correct: false
    explanation: 'CPython is not a programming language. It is the reference implementation
      of Python, written in C.

      '
  - answer: It's a programming language that is a superset of Python, designed to
      produce C-like performance with code written in Python.
    correct: false
    explanation: 'CPython is not a superset of Python. It is the standard implementation
      of Python, written in C for efficient execution of Python code.

      '
  - answer: It's a default, reference implementation of the C language, written in
      Python.
    correct: false
    explanation: 'CPython is not an implementation of the C language. It is an implementation
      of the Python language, written in C.

      '
  - answer: It's a default, reference implementation of the Python language, written
      in C.
    correct: true
    explanation: 'CPython is the default and reference implementation of Python, written
      in C. It is widely used for its compatibility and performance.

      '
  overall_explanation: 'CPython is the standard implementation of Python. Written
    in C, it is the most widely used version of Python and serves as the reference
    implementation.

    '
  question: 'What is CPython?

    '
- domain: 03 - Operators
  options:
  - answer: x % x == 0
    correct: false
    explanation: 'The condition `x % x == 0` always evaluates to true for any non-zero
      value of `x`. It does not check for even numbers.

      '
  - answer: x % 2 == 0
    correct: true
    explanation: 'The expression `x % 2 == 0` checks whether `x` is divisible by 2
      with no remainder, which is the correct condition for even numbers.

      '
  - answer: x % 'even' == True
    correct: false
    explanation: 'The expression `x % ''even''` is invalid in Python. The modulo operator
      `%` cannot be used with a string like `''even''`.

      '
  - answer: x % 1 == 2
    correct: false
    explanation: 'The condition `x % 1 == 2` is not valid for checking even numbers.
      It incorrectly assumes a remainder of 2 from division by 1.

      '
  - answer: x % 2 == 1
    correct: false
    explanation: 'The condition `x % 2 == 1` checks for odd numbers, not even numbers.

      '
  overall_explanation: 'To check for even numbers, the modulo operator `%` is used
    with the condition `x % 2 == 0`. This ensures that `x` is evenly divisible by
    2.

    '
  question: "What would you insert instead of `???` so that the program checks for\
    \ even numbers?\n\n```python\nif ???:\n    print('x is an even number')\n```\n"
- domain: 06 - Functions
  options:
  - answer: return 'number'
    correct: false
    explanation: 'Returning the string `''number''` would not return the value of
      the `number` parameter. The output would be `''number''`, not `7`.

      '
  - answer: print('number')
    correct: false
    explanation: 'Printing `''number''` would display the string `''number''` on the
      console, but it would not return the parameter value.

      '
  - answer: print(number)
    correct: false
    explanation: 'Printing `number` would display its value (`7`) but return `None`.
      The function must return the parameter value.

      '
  - answer: return number
    correct: true
    explanation: 'Returning `number` ensures that the function outputs the value of
      the parameter (`7`) when called.

      '
  overall_explanation: 'To return the value of the parameter, the `return` keyword
    must be used. Printing the value is insufficient as it does not provide a return
    value to the caller.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(number):\n    # insert your code here\n\nprint(func(7))\n```\n"
- domain: 03 - Operators
  options:
  - answer: 1
    correct: false
    explanation: 'The calculation involves multiplying `x` by `y + 1`, which results
      in `4`, not `1`.

      '
  - answer: 4
    correct: true
    explanation: 'The operation `x *= y + 1` evaluates as `x = x * (y + 1)`. Since
      `x = 2` and `y + 1 = 2`, the result is `4`.

      '
  - answer: 3
    correct: false
    explanation: 'The calculation does not result in `3`. The correct result is `4`
      after evaluating the multiplication.

      '
  - answer: None
    correct: false
    explanation: 'The code does not return `None`. It calculates the result of the
      multiplication and prints `4`.

      '
  overall_explanation: 'The `*=` operator combines multiplication and assignment.
    Operator precedence ensures that `y + 1` is calculated first, resulting in `x
    = 2 * 2 = 4`.

    '
  question: 'What will be the output of the following code snippet?


    ```python

    x = 2

    y = 1

    x *= y + 1

    print(x)

    ```

    '
- domain: 02 - Data Types
  options:
  - answer: 30.11E9.0
    correct: false
    explanation: 'Scientific notation in Python requires the exponent to be an integer.
      `30.11E9.0` is invalid due to the decimal point in the exponent.

      '
  - answer: 30.11E9
    correct: true
    explanation: 'Scientific notation in Python uses the format `<number>E<integer>`.
      `30.11E9` correctly represents thirty point eleven times ten raised to the power
      of nine.

      '
  - answer: 30E11.9
    correct: false
    explanation: 'The exponent in scientific notation must be an integer. `30E11.9`
      is not a valid representation.

      '
  - answer: 30.11*10^9
    correct: false
    explanation: '`30.11*10^9` is not valid Python syntax for scientific notation.
      The correct representation is `30.11E9`.

      '
  overall_explanation: 'Scientific notation in Python uses the `E` symbol to denote
    the power of ten. For example, `30.11E9` represents `30.11 * 10^9`.

    '
  question: 'The value thirty point eleven times ten raised to the power of nine should
    be written as:

    '
- domain: 04 - Data Aggregates
  options:
  - answer:
    - 1
    - 3
    - 5
    - 7
    - 9
    correct: true
    explanation: 'The slicing operation `[::2]` selects every second element from
      the list, starting with the first element. The result is `[1, 3, 5, 7, 9]`.

      '
  - answer:
    - 1
    - 2
    - 3
    correct: false
    explanation: 'The slicing `[::2]` selects every second element, not the first
      three elements. The result is `[1, 3, 5, 7, 9]`.

      '
  - answer:
    - 8
    - 9
    correct: false
    explanation: 'The slicing `[::2]` selects every second element from the start,
      not just the last two elements. The result is `[1, 3, 5, 7, 9]`.

      '
  - answer:
    - 1
    - 2
    correct: false
    explanation: 'The slicing `[::2]` selects every second element, not just the first
      two elements. The result is `[1, 3, 5, 7, 9]`.

      '
  overall_explanation: 'The slicing syntax `[start:end:step]` allows for selecting
    elements at specific intervals. The step value `2` ensures every second element
    is selected.

    '
  question: 'What will be the output of the following code snippet?


    ```python

    a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

    print(a[::2])

    ```

    '
- domain: 02 - Data Types
  options:
  - answer: dollar symbol (i.e., $)
    correct: false
    explanation: 'Python does not use the dollar symbol to delimit strings. Strings
      must be enclosed in single or double quotes.

      '
  - answer: double quotes (i.e., ") or single quotes (i.e., ')
    correct: true
    explanation: 'Strings in Python can be enclosed in either single quotes (`''`)
      or double quotes (`"`). Both are valid.

      '
  - answer: backslashes (i.e., \\)
    correct: false
    explanation: 'Backslashes are used to escape characters within strings but are
      not used to delimit strings.

      '
  - answer: asterisks (i.e., *)
    correct: false
    explanation: 'Python does not use asterisks to delimit strings. Strings must be
      enclosed in single or double quotes.

      '
  overall_explanation: 'Python allows flexibility in string delimiters. Either single
    quotes (`''`) or double quotes (`"`) can be used to define string literals.

    '
  question: 'Strings in Python are delimited with:

    '
- domain: 04 - Data Aggregates
  options:
  - answer:
    - 1
    - 3
    correct: false
    explanation: '`list1` and `list2` reference the same list object. Modifying `list1`
      also affects `list2`, so the output is not `[1, 3]`.

      '
  - answer:
    - 1
    - 3
    - 4
    correct: false
    explanation: 'The code modifies an existing element in the list but does not add
      new elements. The output is not `[1, 3, 4]`.

      '
  - answer:
    - 4
    - 3
    correct: true
    explanation: '`list1` and `list2` reference the same list. Changing `list1[0]`
      to `4` updates the shared list, so `list2` outputs `[4, 3]`.

      '
  - answer:
    - 1
    - 4
    correct: false
    explanation: 'The first element of the list is changed to `4`. The output is `[4,
      3]`, not `[1, 4]`.

      '
  overall_explanation: 'Lists are mutable, and assigning one list to another variable
    creates a reference to the same object. Changes to the list affect all references.

    '
  question: 'What is the expected output of the following code?


    ```python

    list1 = [1, 3]

    list2 = list1

    list1[0] = 4

    print(list2)

    ```

    '
- domain: 04 - Data Aggregates
  options:
  - answer: two
    correct: true
    explanation: 'The loop iterates over the dictionary, reassigning `v` based on
      the current value of `dictionary[v]`. After 3 iterations, `v` resolves to `''two''`.

      '
  - answer: ('one', 'two', 'three')
    correct: false
    explanation: 'The output is not a tuple. The loop modifies the variable `v` and
      does not return a collection of the dictionary keys or values.

      '
  - answer: three
    correct: false
    explanation: 'Although `''three''` is a value in the dictionary, the loop resolves
      `v` to `''two''` after the final iteration.

      '
  - answer: one
    correct: false
    explanation: 'While `''one''` is initially part of the key-value resolution, the
      loop iterates until `v` resolves to `''two''`.

      '
  overall_explanation: 'The loop iterates through the dictionary values, starting
    with the value of `''one''`, and resolves `v` through three iterations to the
    final value `''two''`.

    '
  question: "What is the output of the following snippet?\n\n```python\ndictionary\
    \ = {'one': 'two', 'three': 'one', 'two': 'three'}\nv = dictionary['one']\n\n\
    for k in range(len(dictionary)):\n    v = dictionary[v]\n\nprint(v)\n```\n"
- domain: 01 - Basics
  options:
  - answer: 2 1
    correct: true
    explanation: 'The variables are reassigned as follows: `x` takes the value of
      `y` (`2`), and `y` takes the value of `z` (`1`). The output is `2 1`.

      '
  - answer: 1 2
    correct: false
    explanation: 'The values of `x` and `y` are swapped during reassignment. The output
      is not `1 2`.

      '
  - answer: 1 1
    correct: false
    explanation: 'The variable `y` is reassigned to the value of `z`, which holds
      the initial value of `x`. The output is `2 1`, not `1 1`.

      '
  - answer: 2 2
    correct: false
    explanation: 'The variables are swapped, resulting in `x = 2` and `y = 1`. The
      output is not `2 2`.

      '
  overall_explanation: 'Variables are reassigned during the code execution. `z` temporarily
    holds the value of `x`, allowing the values of `x` and `y` to be swapped.

    '
  question: 'What is the expected output of the following code snippet?


    ```python

    x = 1

    y = 2

    z = x

    x = y

    y = z

    print(x, y)

    ```

    '
- domain: 04 - Data Aggregates
  options:
  - answer: '[''h'' ''e'' ''l'' ''l'' ''o'']'
    correct: false
    explanation: 'The output must include commas between the elements to create a
      valid list. The correct output is `[''h'', ''e'', ''l'', ''l'', ''o'']`.

      '
  - answer: hello
    correct: false
    explanation: 'The `list()` function converts a string into a list of individual
      characters. The output is not the string `''hello''`.

      '
  - answer:
    - h
    - e
    - l
    - l
    - o
    correct: true
    explanation: 'The `list()` function splits the string `''hello''` into a list
      of its characters: `[''h'', ''e'', ''l'', ''l'', ''o'']`.

      '
  - answer: None of the above.
    correct: false
    explanation: 'The correct output is `[''h'', ''e'', ''l'', ''l'', ''o'']`.

      '
  - answer:
    - h
    - e
    - l
    - l
    - o
    correct: false
    explanation: 'Elements in a list must be quoted to be valid strings. The correct
      output is `[''h'', ''e'', ''l'', ''l'', ''o'']`.

      '
  overall_explanation: 'The `list()` function converts a string into a list of its
    characters. Each character becomes an individual string element in the list.

    '
  question: 'What is the expected output of the following code?


    ```python

    print(list(''hello''))

    ```

    '
- domain: 02 - Data Types
  options:
  - answer: 1 1 1
    correct: false
    explanation: 'The `sep=''*''` argument specifies that the values are separated
      by `*`, not spaces. The correct output is `1*1*1`.

      '
  - answer: 1*1*1
    correct: true
    explanation: 'The `sep=''*''` argument in the `print()` function separates the
      values with an asterisk. Since `x`, `y`, and `z` are all `1`, the output is
      `1*1*1`.

      '
  - answer: 111*
    correct: false
    explanation: 'The output separates values with `*`. It does not concatenate all
      values into a single string like `111*`.

      '
  - answer: x*y*z
    correct: false
    explanation: 'The output is not a mathematical expression. It simply prints the
      values separated by `*`.

      '
  overall_explanation: 'The `print()` function with the `sep` argument customizes
    the separator between values. Here, `sep=''*''` results in `1*1*1`.

    '
  question: 'What is the expected output of the following code?


    ```python

    z = y = x = 1

    print(x, y, z, sep=''*'')

    ```

    '
- domain: 04 - Data Aggregates
  options:
  - answer:
    - 1
    - 3
    - 4
    - 5
    - 20
    - 5
    - 25
    correct: false
    explanation: 'This is incorrect because `pop(1)` removes the second element (4)
      from the list. The resulting list is `[3, 5, 20, 5, 25, 1, 3]`.

      '
  - answer:
    - 1
    - 3
    - 3
    - 4
    - 5
    - 5
    - 20
    - 25
    correct: false
    explanation: 'The `pop()` method only removes an element; it does not duplicate
      or rearrange the list elements.

      '
  - answer:
    - 3
    - 4
    - 5
    - 20
    - 5
    - 25
    - 1
    - 3
    correct: false
    explanation: 'This is the original list. After the `pop()` operation, the element
      at index 1 is removed, resulting in a modified list.

      '
  - answer:
    - 3
    - 5
    - 20
    - 5
    - 25
    - 1
    - 3
    correct: true
    explanation: 'The `pop(1)` method removes the second element of the list (`4`).
      The modified list is `[3, 5, 20, 5, 25, 1, 3]`.

      '
  overall_explanation: 'The `pop()` method removes the element at the specified index
    and returns it. After `nums.pop(1)`, the second element (`4`) is removed, modifying
    the list.

    '
  question: 'What is the expected output of the following code snippet?


    ```python

    nums = [3, 4, 5, 20, 5, 25, 1, 3]

    nums.pop(1)

    print(nums)

    ```

    '
- domain: 01 - Basics
  options:
  - answer: The code is erroneous.
    correct: false
    explanation: 'The code is valid. The backslash (`\`) escapes the single quote,
      making it part of the string.

      '
  - answer: 1
    correct: true
    explanation: 'The string contains one character: an escaped single quote (`''`).
      The `len()` function returns `1`.

      '
  - answer: 2
    correct: false
    explanation: 'The length is not `2`. The backslash (`\`) is an escape character
      and does not count as a separate character.

      '
  - answer: 0
    correct: false
    explanation: 'The string contains one character, so the length is not `0`.

      '
  overall_explanation: 'The backslash (`\`) is an escape character that allows special
    characters (e.g., `''`) to be included in strings. The length of the string is
    `1`.

    '
  question: 'What is the expected output of the following code?


    ```python

    x = ''\''''

    print(len(x))

    ```

    '
- domain: 06 - Functions
  options:
  - answer: fun
    correct: false
    explanation: '`fun` is not a Python keyword. The correct keyword to define a function
      is `def`.

      '
  - answer: function
    correct: false
    explanation: '`function` is not a Python keyword for defining functions. The keyword
      `def` is used instead.

      '
  - answer: def
    correct: true
    explanation: 'The keyword `def` is used in Python to define functions.

      '
  overall_explanation: 'In Python, functions are defined using the `def` keyword,
    followed by the function name, parameters (if any), and a colon (`:`).

    '
  question: "A function definition starts with the keyword:\n\n```python\ndef my_function():\n\
    \    pass\n```\n"
- domain: 03 - Operators
  options:
  - answer: is equal to 123
    correct: false
    explanation: 'Adding an integer and a float always results in a float. The output
      is `123.0`, not `123`.

      '
  - answer: is equal to 123.0
    correct: true
    explanation: 'The addition of an integer and a float promotes the result to a
      float. The correct result is `123.0`.

      '
  - answer: cannot be evaluated
    correct: false
    explanation: 'The operation is valid in Python and results in `123.0`.

      '
  overall_explanation: 'Python automatically converts integers to floats during arithmetic
    operations involving both types. Adding `123` (integer) and `0.0` (float) results
    in `123.0`.

    '
  question: 'The result of the following addition:


    ```python

    123 + 0.0

    ```

    '
- domain: 06 - Functions
  options:
  - answer: will not affect the argument
    correct: false
    explanation: 'Lists in Python are mutable. Modifications inside a function affect
      the original list passed as an argument.

      '
  - answer: will affect the argument
    correct: true
    explanation: 'Lists are passed by reference in Python. Changes, including deletions,
      affect the original list.

      '
  - answer: will cause a runtime error
    correct: false
    explanation: 'The `del` instruction does not cause runtime errors when applied
      to a valid list index.

      '
  overall_explanation: 'Python passes mutable objects like lists by reference. Changes
    made inside a function, such as deleting elements, directly affect the original
    list.

    '
  question: 'If a list is passed into a function as an argument, deleting any of its
    elements inside the function using the `del` instruction:

    '
- domain: 06 - Functions
  options:
  - answer: false
    correct: false
    explanation: 'The function `fun()` does not return `False`. It is defined to always
      return `True`.

      '
  - answer: 0
    correct: false
    explanation: 'The function does not return an integer. It always returns a boolean
      value, specifically `True`.

      '
  - answer: The program will cause an error
    correct: true
    explanation: 'The program will raise a `TypeError` because `fun()` is defined
      without parameters, but it is called with one argument (`False`).

      '
  - answer: true
    correct: false
    explanation: 'The program does not execute successfully due to a `TypeError`.
      If the function were called correctly, it would return `True`.

      '
  - answer: 1
    correct: false
    explanation: 'The function does not return an integer. It is defined to return
      `True`, but the program raises an error before reaching this point.

      '
  overall_explanation: 'The function `fun()` is defined without parameters, so calling
    it with an argument (`False`) causes a `TypeError`. Python does not allow extra
    arguments for functions with no defined parameters.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ fun():\n    return True\nx = fun(False)\nprint(x)\n```\n"
- domain: 03 - Operators
  options:
  - answer: 17
    correct: false
    explanation: 'The correct output is `17.5`. The division `1 / 2` results in `0.5`,
      which is added to the results of `3 // 3` and `4 ** 2`.

      '
  - answer: 8.5
    correct: false
    explanation: 'The correct result is `17.5`. The division `1 / 2` contributes `0.5`,
      while `3 // 3` adds `1` and `4 ** 2` adds `16`.

      '
  - answer: 8
    correct: false
    explanation: 'The output is not `8`. The sum of the evaluated expressions is `17.5`.

      '
  - answer: 17.5
    correct: true
    explanation: 'The expression evaluates as follows:

      - `1 / 2` is `0.5`

      - `3 // 3` is `1`

      - `4 ** 2` is `16`

      Summing these values gives `17.5`.

      '
  overall_explanation: 'Python evaluates arithmetic expressions following operator
    precedence:

    1. Exponentiation (`**`)

    2. Division and floor division (`/`, `//`)

    3. Addition (`+`)

    The final result is `17.5`.

    '
  question: 'What is the expected output of the following code?


    ```python

    x = 1 / 2 + 3 // 3 + 4 ** 2

    print(x)

    ```

    '
- domain: 06 - Functions
  options:
  - answer: fun()
    correct: false
    explanation: 'The function requires at least two positional arguments (`a` and
      `b`). Calling it without arguments results in a `TypeError`.

      '
  - answer: fun(0, 1, 2)
    correct: true
    explanation: 'This correctly provides values for all parameters: `a=0`, `b=1`,
      and `c=2`. The default value of `c` is overridden by the provided value.

      '
  - answer: fun(b=1)
    correct: false
    explanation: 'The function requires at least two arguments, and only `b` is provided.
      This results in a `TypeError` for the missing argument `a`.

      '
  - answer: fun(b=0, a=0)
    correct: true
    explanation: 'This correctly uses keyword arguments to assign values to `a` and
      `b`. The default value of `c` remains `0`.

      '
  overall_explanation: 'The function requires at least two arguments (`a` and `b`).
    Providing these either positionally or using keywords is valid. The default value
    for `c` is used if no value is provided.

    '
  question: "Which of the following lines correctly invoke the function defined below:\n\
    \n```python\ndef fun(a, b, c=0):\n    pass\n```\n\n(Select two answers)\n"
- domain: 06 - Functions
  options:
  - answer: '**'
    correct: false
    explanation: 'The function doubles the string in each loop iteration. For `num=2`,
      the string becomes `****`, not `**`.

      '
  - answer: The code is erroneous.
    correct: false
    explanation: 'The code is valid and executes without errors. It correctly generates
      and prints the string `****`.

      '
  - answer: '*'
    correct: false
    explanation: 'The function doubles the string in each iteration of the loop. For
      `num=2`, the result is `****`, not `*`.

      '
  - answer: '****'
    correct: true
    explanation: 'The function generates a string by doubling `''*''` in each iteration.
      For `num=2`, the result is `''*'' -> ''**'' -> ''****''`.

      '
  overall_explanation: 'The function initializes `res` as `''*''` and doubles it in
    each iteration of the loop. After two iterations, `res` becomes `****`, which
    is printed character by character in the outer loop.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(num):\n    res = '*'\n    for _ in range(num):\n        res += res\n  \
    \  return res\n\nfor x in func(2):\n    print(x, end='')\n```\n"
- domain: 05 - Control Flow
  options:
  - answer: 2
    correct: false
    explanation: 'The loop breaks during the first iteration when `i` becomes `2`.
      Only one star is printed, and the `else` block is skipped.

      '
  - answer: 0
    correct: false
    explanation: 'The loop runs at least once before the `break` statement. One star
      is printed.

      '
  - answer: 1
    correct: true
    explanation: 'The loop prints one star during the first iteration before breaking
      when `i == 2`. The `else` block is not executed due to the `break`.

      '
  - answer: The snippet will enter an infinite loop.
    correct: false
    explanation: 'The loop condition ensures termination. The `break` statement exits
      the loop when `i == 2`.

      '
  overall_explanation: 'The `break` statement in the loop prevents the `else` block
    from executing. The loop runs once, printing a single star before terminating.

    '
  question: "How many stars will the following snippet print to the monitor?\n\n```python\n\
    i = 4\nwhile i > 0:\n    i -= 2\n    print('*')\n    if i == 2:\n        break\n\
    else:\n    print('*')\n```\n"
- domain: 04 - Data Aggregates
  options:
  - answer: 1
    correct: false
    explanation: 'The value of key ''1'' in the dictionary is 2, and the value of
      key 1 is incremented to 2. Thus, the total sum is 4.

      '
  - answer: 2
    correct: false
    explanation: 'The sum of the dictionary values is not 2. The values are incremented
      correctly to result in a sum of 4.

      '
  - answer: 4
    correct: true
    explanation: 'The dictionary has keys 1 and ''1'' with values 2 each after the
      operations. The sum of all values is 2 + 2 = 4.

      '
  - answer: 3
    correct: false
    explanation: 'The sum of the dictionary values is not 3. The values after operations
      sum up to 4.

      '
  overall_explanation: 'In Python, dictionaries can have keys of different data types.
    Here, `1` and `''1''` are treated as separate keys. The value for key `1` is incremented
    to 2, and the sum of all values in the dictionary is 4.

    '
  question: "What is the output of the following code snippet?\n\n```python\nd = {}\n\
    d[1] = 1\nd['1'] = 2\nd[1] += 1\n\nsum = 0\n\nfor k in d:\n    sum += d[k]\n\n\
    print(sum)\n```\n"
- domain: 06 - Functions
  options:
  - answer: The code is erroneous.
    correct: false
    explanation: 'The code runs without errors. It demonstrates the difference between
      mutable and immutable data types in Python.

      '
  - answer: 3 42
    correct: true
    explanation: '`x` is an integer (immutable) and remains unchanged. `y` is a list
      (mutable), so changes to it inside the function are reflected in the original
      list.

      '
  - answer: 1 42
    correct: false
    explanation: 'The value of `x` is not modified outside the function because integers
      are immutable in Python.

      '
  - answer: 3 1
    correct: false
    explanation: 'The first element of `y` is modified inside the function to 42,
      so the output is not `3 1`.

      '
  - answer: 1 1
    correct: false
    explanation: 'The list `y` is modified, and the first element becomes 42. The
      integer `x` remains unchanged.

      '
  overall_explanation: 'This code highlights the difference between mutable and immutable
    types. Integers are immutable, so assigning `p1 = 1` does not affect `x`. Lists
    are mutable, so modifying `p2[0]` changes the original list `y`.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(p1, p2):\n    p1 = 1\n    p2[0] = 42\n\nx = 3\ny = [1, 2, 3]\n\nfunc(x,\
    \ y)\n\nprint(x, y[0])\n```\n"
- domain: 05 - Control Flow
  options:
  - answer: one
    correct: false
    explanation: 'The loop increments `i` by 2 each time and prints a star in each
      iteration. It runs twice, not once.

      '
  - answer: two
    correct: true
    explanation: 'The loop runs twice: first with `i = 0` and then with `i = 2`. Each
      time, it prints a star. The loop ends when `i = 4`.

      '
  - answer: three
    correct: false
    explanation: 'The loop does not run three times. It only runs for `i = 0` and
      `i = 2`, printing two stars in total.

      '
  - answer: zero
    correct: false
    explanation: 'The loop runs twice and prints two stars, so the output is not zero
      stars.

      '
  overall_explanation: 'The loop runs twice: once with `i = 0` and once with `i =
    2`. On each iteration, a star is printed. The loop stops when `i` exceeds 3.

    '
  question: "How many stars will the following code print to the monitor?\n\n```python\n\
    i = 0\nwhile i <= 3:\n    i += 2\n    print('*')\n```\n"
- domain: 06 - Functions
  options:
  - answer: ace
    correct: true
    explanation: 'The function iterates over every second character in the string
      ''abcdef'' and yields ''a'', ''c'', and ''e'', which are printed without spaces.

      '
  - answer: An empty line.
    correct: false
    explanation: 'The function yields characters ''a'', ''c'', and ''e'', so the output
      is not an empty line.

      '
  - answer: bdf
    correct: false
    explanation: 'The slicing `[::2]` selects every second character starting with
      the first, so the output is not ''bdf''.

      '
  - answer: abcdef
    correct: false
    explanation: 'The function does not iterate over every character. It selects every
      second character, resulting in ''ace''.

      '
  overall_explanation: 'The slicing `[::2]` selects every second character from the
    string ''abcdef''. The generator yields these characters, and they are printed
    as ''ace''.

    '
  question: "What is the expected output of the following code?\n\n```python\ndef\
    \ func(data):\n    for d in data[::2]:\n        yield d\n\nfor x in func('abcdef'):\n\
    \    print(x, end='')\n```\n"
